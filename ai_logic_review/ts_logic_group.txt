
================================================================================
FILE_BEGIN: constants\images.ts
METADATA: Size=4125 bytes | Last_Modified=2026-01-07 07:25:59.134492
================================================================================
/**
 * Centralized Asset Registry
 * Maps application logic to physical file paths.
 *
 * Usage:
 * import { IMAGES } from '../constants/images';
 * <img src={IMAGES.BANNERS.HERO_HOME} alt="Home" />
 *
 * Icons Usage:
 * import { IMAGES } from '../constants/images';
 * <img src={IMAGES.ICONS.SOLDIER} alt="Veteran Support" className="w-6 h-6" />
 */

export const IMAGES = {
  // Brand Assets
  LOGO: {
    PNG: '/images/logo/brand-logo.png',
    SVG: '/images/logo/brand-logo.svg',
  },

  // Page Hero Banners
  BANNERS: {
    HERO_HOME: '/images/banners/hero-home-banner-800w.webp',
    HERO_ABOUT: '/images/banners/hero-about-us-banner-400w.webp',
    HERO_CONTACT: '/images/banners/hero-about-banner-1280.webp',
    HERO_IMPACT: '/images/banners/hero-impact-banner-400w.webp',
    HERO_PRIVACY: '/images/banners/hero-privacy-banner.webp',
    HERO_PROJECTS: '/images/banners/hero-projects-banner-1920.webp',
    HERO_RESOURCES: '/images/banners/hero-resources-banner-1920.webp',
    HERO_TERMS: '/images/banners/hero-terms-banner-1200w.webp',
    HERO_TRANSPARENCY: '/images/banners/hero-transparency-banner-400w.webp',
    HERO_APPLICATION: '/images/banners/hero-application-banner.webp',
    HERO_FAQ: '/images/banners/hero-faq-banner.png',
  },

  // Property Listings
  PROPERTIES: {
    TYLER_RANCH: '/images/properties/tyler-ranch-home.webp',
    JEFFERSON_RIVER: '/images/properties/jefferson-river.webp',
    KEMP_TOWNHOME: '/images/properties/kemp-townhome.webp',
    LONGVIEW_VICTORIAN: '/images/properties/longview-victorian.webp',
    MARSHALL_FARMHOUSE: '/images/properties/marshall-farmhouse-400w.webp',
    MINEOLA_STUDIO: '/images/properties/mineola-studio.webp',
    LINDALE_COTTAGE: '/images/properties/lindale-cottage.webp',
  },

  // Team & About
  TEAM: {
    OWNER: '/images/about/about-us-team-owner.png',
    HEADSHOT: '/images/about/about-us-team-headshot.png',
  },

  // Renovation Showcase (Before/After)
  RENOVATION: {
    BATHROOM: {
      BEFORE:
        '/images/before-after-comparison/projects-before-bathroom-800w.webp',
      AFTER:
        '/images/before-after-comparison/projects-after-bathroom-800w.webp',
    },
    KITCHEN: {
      BEFORE:
        '/images/before-after-comparison/projects-before-kitchen-800w.webp',
      AFTER: '/images/before-after-comparison/projects-after-kitchen-800w.webp',
    },
    LIVING_ROOM: {
      BEFORE:
        '/images/before-after-comparison/projects-before-living-room-800w.webp',
      AFTER:
        '/images/before-after-comparison/projects-after-living-room-800w.webp',
    },
    PORCH: {
      BEFORE:
        '/images/before-after-comparison/projects-before-front-porch-400w.webp',
      AFTER:
        '/images/before-after-comparison/projects-after-front-porch-800w.webp',
    },
  },

  // Gallery / Work
  GALLERY: {
    FRAMING: '/images/our-work-gallery/our-work-framing-door.webp',
    PAINTING: '/images/our-work-gallery/our-work-painting-dog-800w.webp',
    MEASURING: '/images/our-work-gallery/our-work-detailed-measuring-800w.webp',
    REMODELING: '/images/our-work-gallery/our-work-remodeling-400w.webp',
  },

  // Icon System - Key icons for the veteran/family housing platform
  ICONS: {
    // Core Brand Icons
    SOLDIER: '/images/icons/soldier.svg',
    FLAG: '/images/icons/flag.svg',
    HEART: '/images/icons/heart.svg',
    HOME: '/images/icons/home.svg',
    FAMILY: '/images/icons/family.svg',

    // Property & Construction Icons
    PATIO: '/images/icons/american-flag-icon.svg',
    QUALITY: '/images/icons/quality-checklist.svg',
    COMMUNITY: '/images/icons/online-community.svg',
    PATRIOTISM: '/images/icons/patriotism.svg',

    // Additional Support Icons
    VA_LOAN: '/images/icons/032-va-loan.png',
    SUPPORT: '/images/icons/019-heart.png',
    QUALITY_CONTROL: '/images/icons/009-quality-control.png',
    STANDARD: '/images/icons/012-quality-control-1.png',
  },

  // Videos
  VIDEOS: {
    HERO_PROPERTIES: '/images/videos/hero-properties-banner.mp4',
    HERO_WORK: '/images/videos/hero-our-work-banner.mp4',
    SUCCESS_STORY: '/images/videos/success-story.mp4',
  },
} as const;


[FILE_END: constants\images.ts]
################################################################################

================================================================================
FILE_BEGIN: data\properties.ts
METADATA: Size=5274 bytes | Last_Modified=2026-01-05 21:05:53.876867
================================================================================
import type { Property } from '../types';
import { IMAGES } from '../constants/images';

export interface ExtendedProperty extends Property {
  amenities: string[];
  accessibilityFeatures: string[];
  schoolDistrict: string;
  neighborhood: string;
  availabilityDate: string;
  coordinates: { lat: number; lng: number };
}

export const properties: ExtendedProperty[] = [
  {
    id: '1',
    title: 'The Magnolia Residence',
    address: '1245 Oakwood Dr, Tyler, TX',
    price: 950,
    beds: 3,
    baths: 2,
    sqft: 1450,
    imageUrl: IMAGES.PROPERTIES.TYLER_RANCH,
    badges: ['Section 8 Approved', 'Wheelchair Accessible'],
    description:
      'Fully renovated single-family home featuring quartz countertops, new HVAC, and a spacious fenced backyard perfect for families. Located within walking distance of Douglas Elementary School.',
    amenities: [
      'Quartz Countertops',
      'Fenced Backyard',
      'Central HVAC',
      'Dishwasher',
      'Washer/Dryer Hookups',
    ],
    accessibilityFeatures: [
      'Wheelchair Ramp',
      'Wide Doorways (36")',
      'Grab Bars in Bathroom',
    ],
    schoolDistrict: 'Tyler ISD',
    neighborhood: 'Azalea District',
    availabilityDate: 'Available Now',
    coordinates: { lat: 32.3513, lng: -95.3011 },
  },
  {
    id: '2',
    title: 'Veterans Harbor',
    address: '880 Pine Street, Longview, TX',
    price: 875,
    beds: 2,
    baths: 1.5,
    sqft: 1100,
    imageUrl: IMAGES.PROPERTIES.MINEOLA_STUDIO,
    badges: ['HUD-VASH Preferred', 'Near VA Clinic'],
    description:
      'Cozy bungalow tailored for veterans. Includes walk-in shower, energy-efficient appliances, and dedicated parking. Quiet neighborhood with community garden nearby.',
    amenities: [
      'Energy Star Appliances',
      'Dedicated Parking',
      'Community Garden Access',
      'Security System',
    ],
    accessibilityFeatures: [
      'Step-free Entrance',
      'Roll-in Shower',
      'Lever Handles',
    ],
    schoolDistrict: 'Longview ISD',
    neighborhood: 'Pine Tree',
    availabilityDate: 'October 15, 2023',
    coordinates: { lat: 32.5007, lng: -94.7405 },
  },
  {
    id: '3',
    title: 'Creekview Estate',
    address: '300 Cedar Lane, Marshall, TX',
    price: 1100,
    beds: 4,
    baths: 2,
    sqft: 1800,
    imageUrl: IMAGES.PROPERTIES.MARSHALL_FARMHOUSE,
    badges: ['Fenced Yard', 'New Roof'],
    description:
      'Spacious family home with open floor plan. Brand new luxury vinyl plank flooring throughout and modernized kitchen. Features a covered patio and detached garage.',
    amenities: [
      'LVP Flooring',
      'Covered Patio',
      'Detached Garage',
      'Walk-in Closets',
    ],
    accessibilityFeatures: ['Flat Thresholds'],
    schoolDistrict: 'Marshall ISD',
    neighborhood: 'Historic District',
    availabilityDate: 'November 1, 2023',
    coordinates: { lat: 32.5449, lng: -94.3674 },
  },
  {
    id: '4',
    title: 'Liberty Row',
    address: '405 Freedom Blvd, Tyler, TX',
    price: 1050,
    beds: 3,
    baths: 2,
    sqft: 1600,
    imageUrl: IMAGES.PROPERTIES.LONGVIEW_VICTORIAN,
    badges: ['New Construction', 'Energy Star'],
    description:
      'A complete restoration project turned modern sanctuary. Open concept living area, LED lighting throughout, and a brand new thermal insulation package to keep utility bills low.',
    amenities: [
      'LED Lighting',
      'Smart Thermostat',
      'Thermal Insulation',
      'Open Concept',
    ],
    accessibilityFeatures: ['Accessible Parking'],
    schoolDistrict: 'Tyler ISD',
    neighborhood: 'Downtown Tyler',
    availabilityDate: 'Available Now',
    coordinates: { lat: 32.3513, lng: -95.3011 },
  },
  {
    id: '5',
    title: 'The Patriot Duplex',
    address: '220 Victory Lane, Kilgore, TX',
    price: 825,
    beds: 2,
    baths: 1,
    sqft: 950,
    imageUrl: IMAGES.PROPERTIES.KEMP_TOWNHOME,
    badges: ['Rapid Rehousing', 'Pet Friendly'],
    description:
      'Affordable duplex unit recently updated with fresh paint and new appliances. Large shared yard and close to public transit routes.',
    amenities: ['Fresh Paint', 'Shared Yard', 'Pet Friendly', 'Transit Access'],
    accessibilityFeatures: ['Ground Floor Unit'],
    schoolDistrict: 'Kilgore ISD',
    neighborhood: 'Sycamore Grove',
    availabilityDate: 'Waitlist Open',
    coordinates: { lat: 32.3852, lng: -94.8767 },
  },
  {
    id: '6',
    title: 'Freedom Heights',
    address: '1500 Independence Dr, Lindale, TX',
    price: 1250,
    beds: 3,
    baths: 2.5,
    sqft: 1750,
    imageUrl: IMAGES.PROPERTIES.LINDALE_COTTAGE,
    badges: ['Family Size', 'Top Rated Schools'],
    description:
      'Beautiful brick home in the highly sought-after Lindale school district. Features a double vanity, large soaking tub, and a fireplace for cozy evenings.',
    amenities: ['Fireplace', 'Double Vanity', 'Soaking Tub', 'Brick Exterior'],
    accessibilityFeatures: ['Paved Walkways'],
    schoolDistrict: 'Lindale ISD',
    neighborhood: 'Eagle Creek',
    availabilityDate: 'December 1, 2023',
    coordinates: { lat: 32.5165, lng: -95.4093 },
  },
];

export const getPropertyById = (
  id: string | undefined,
): ExtendedProperty | undefined => properties.find((p) => p.id === id);


[FILE_END: data\properties.ts]
################################################################################

================================================================================
FILE_BEGIN: services\api.ts
METADATA: Size=11664 bytes | Last_Modified=2026-01-07 07:18:19.232005
================================================================================
import type {
  StatMetric,
  RenovationStandard,
  FinancialBreakdown,
} from '../types';
import type { ExtendedProperty } from '../data/properties';
import { properties, getPropertyById } from '../data/properties';

/**
 * Enhanced Backend API Service
 *
 * This service supports both development (mock data) and production (real backend) modes.
 *
 * Development Mode (Default):
 * - Uses mock data with simulated network latency
 * - No environment variables required
 * - Perfect for frontend development and testing
 *
 * Production Mode:
 * - Set VITE_API_URL environment variable to enable real backend integration
 * - Falls back to mock data if backend is unavailable
 * - Automatic switching based on environment configuration
 *
 * Environment Setup:
 * - Copy .env.example to .env and configure VITE_API_URL
 * - Development: Leave VITE_API_URL empty (uses mock data)
 * - Production: Set VITE_API_URL to your backend endpoint
 */

const SIMULATED_LATENCY = 800; // ms

// Environment configuration for backend integration
const API_CONFIG = {
  // Get API URL from environment variable, fallback to empty string for mock data
  // eslint-disable-next-line dot-notation
  baseUrl: import.meta.env['VITE_API_URL'] || "",

  // Check if we're in backend mode (has API URL) or mock mode (no API URL)
  get isBackendMode() {
    return this.baseUrl.trim().length > 0;
  },

  // Get full API endpoint URL
  getEndpointUrl(endpoint: string): string {
    return `${this.baseUrl.replace(/\/$/, '')}${endpoint.startsWith('/') ? endpoint : `/${endpoint}`}`;
  },
};

/**
 * HTTP client for backend communication
 * Automatically falls back to mock data on network errors
 */
class ApiClient {
  private async makeRequest<T>(
    endpoint: string,
    options?: RequestInit,
  ): Promise<T> {
    if (!API_CONFIG.isBackendMode) {
      throw new Error('Backend mode disabled - using mock data');
    }

    try {
      const url = API_CONFIG.getEndpointUrl(endpoint);
      const response = await fetch(url, {
        headers: {
          'Content-Type': 'application/json',
          ...options?.headers,
        },
        ...options,
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      console.warn(
        `Backend request failed for endpoint ${endpoint}, falling back to mock data:`,
        error,
      );
      throw new Error('Backend unavailable - using mock data');
    }
  }

  async get<T>(endpoint: string): Promise<T> {
    return this.makeRequest<T>(endpoint, { method: 'GET' });
  }

  async post<T>(endpoint: string, data?: any): Promise<T> {
    return this.makeRequest<T>(endpoint, {
      method: 'POST',
      body: data ? JSON.stringify(data) : null,
    });
  }
}

const apiClient = new ApiClient();

export const api = {
  impact: {
    /**
     * Get impact metrics
     * Tries backend first if VITE_API_URL is set, falls back to mock data
     */
    getMetrics: async (): Promise<StatMetric[]> => {
      try {
        // Try backend first if in backend mode
        if (API_CONFIG.isBackendMode) {
          const data = await apiClient.get<StatMetric[]>('/api/impact/metrics');
          return data;
        }
      } catch (error) {
        console.warn('Backend metrics request failed, using mock data:', error);
      }

      // Fallback to mock data
      await new Promise((resolve) => setTimeout(resolve, SIMULATED_LATENCY));
      return [
        {
          id: '1',
          label: 'Families Housed',
          value: '142',
          icon: 'home',
          description: 'Total families placed in safe, renovated homes.',
          trend: 'up',
          trendValue: '+12% this year',
        },
        {
          id: '2',
          label: 'Veterans Served',
          value: '85',
          icon: 'users',
          description: 'Veterans housed via HUD-VASH or direct placement.',
          trend: 'up',
          trendValue: '+8% this year',
        },
        {
          id: '3',
          label: 'Properties Revitalized',
          value: '56',
          icon: 'hammer',
          description: 'Distressed properties fully renovated.',
          trend: 'up',
          trendValue: '+5 this quarter',
        },
        {
          id: '4',
          label: 'Community Wealth',
          value: '$2.4M',
          icon: 'dollar',
          description: 'Estimated property value added to local neighborhoods.',
          trend: 'up',
          trendValue: 'Est. Value',
        },
      ];
    },

    /**
     * Get financial breakdown
     * Tries backend first if VITE_API_URL is set, falls back to mock data
     */
    getFinancialBreakdown: async (): Promise<FinancialBreakdown[]> => {
      try {
        // Try backend first if in backend mode
        if (API_CONFIG.isBackendMode) {
          const data = await apiClient.get<FinancialBreakdown[]>(
            '/api/impact/financial-breakdown',
          );
          return data;
        }
      } catch (error) {
        console.warn(
          'Backend financial breakdown request failed, using mock data:',
          error,
        );
      }

      // Fallback to mock data
      await new Promise((resolve) => setTimeout(resolve, SIMULATED_LATENCY));
      return [
        { category: 'Property Maintenance', percentage: 35, color: '#0B1120' },
        { category: 'Future Acquisitions', percentage: 30, color: '#C5A059' },
        { category: 'Investor Returns', percentage: 20, color: '#334155' },
        { category: 'Community Programs', percentage: 10, color: '#94a3b8' },
        { category: 'Admin/Ops', percentage: 5, color: '#cbd5e1' },
      ];
    },
  },

  transparency: {
    /**
     * Get renovation standards
     * Tries backend first if VITE_API_URL is set, falls back to mock data
     */
    getStandards: async (): Promise<RenovationStandard[]> => {
      try {
        // Try backend first if in backend mode
        if (API_CONFIG.isBackendMode) {
          const data = await apiClient.get<RenovationStandard[]>(
            '/api/transparency/standards',
          );
          return data;
        }
      } catch (error) {
        console.warn(
          'Backend standards request failed, using mock data:',
          error,
        );
      }

      // Fallback to mock data
      await new Promise((resolve) => setTimeout(resolve, SIMULATED_LATENCY));
      return [
        {
          id: 'kitchen',
          category: 'Kitchen Countertops',
          standardLandlord: 'Laminate / Formica',
          p4cStandard: 'Quartz or Granite',
          benefit: 'Hygienic, durable, heat resistant, and dignified.',
        },
        {
          id: 'flooring',
          category: 'Flooring',
          standardLandlord: 'Cheap Carpet or Sheet Vinyl',
          p4cStandard: 'Luxury Vinyl Plank (LVP)',
          benefit:
            'Waterproof, allergen-free, pet-friendly, and lasts 10+ years.',
        },
        {
          id: 'hvac',
          category: 'Climate Control',
          standardLandlord: 'Repair old units until failure',
          p4cStandard: 'New High-Efficiency SEER 16+',
          benefit:
            'Lowers tenant utility bills by ~25% and ensures reliability.',
        },
        {
          id: 'security',
          category: 'Security',
          standardLandlord: 'Standard deadbolt',
          p4cStandard: 'Smart Locks + Motion Lighting',
          benefit: 'Enhanced safety for families and peace of mind.',
        },
      ];
    },
  },

  properties: {
    /**
     * Get all available properties
     * Tries backend first if VITE_API_URL is set, falls back to mock data
     */
    getAll: async (): Promise<ExtendedProperty[]> => {
      try {
        // Try backend first if in backend mode
        if (API_CONFIG.isBackendMode) {
          const data =
            await apiClient.get<ExtendedProperty[]>('/api/properties');
          return data;
        }
      } catch (error) {
        console.warn(
          'Backend properties request failed, using mock data:',
          error,
        );
      }

      // Fallback to mock data
      await new Promise((resolve) => setTimeout(resolve, SIMULATED_LATENCY));
      return properties;
    },

    /**
     * Get a specific property by ID
     * Tries backend first if VITE_API_URL is set, falls back to mock data
     */
    getById: async (id: string): Promise<ExtendedProperty | null> => {
      try {
        // Try backend first if in backend mode
        if (API_CONFIG.isBackendMode) {
          const data = await apiClient.get<ExtendedProperty>(
            `/api/properties/${id}`,
          );
          return data;
        }
      } catch (error) {
        console.warn(
          'Backend property by ID request failed, using mock data:',
          error,
        );
      }

      // Fallback to mock data
      await new Promise((resolve) => setTimeout(resolve, SIMULATED_LATENCY));
      const property = getPropertyById(id);
      return property || null;
    },

    /**
     * Search properties by criteria
     * Tries backend first if VITE_API_URL is set, falls back to mock data
     */
    search: async (criteria: {
      minPrice?: number;
      maxPrice?: number;
      beds?: number;
      baths?: number;
      neighborhood?: string;
      schoolDistrict?: string;
    }): Promise<ExtendedProperty[]> => {
      try {
        // Try backend first if in backend mode
        if (API_CONFIG.isBackendMode) {
          const data = await apiClient.post<ExtendedProperty[]>(
            '/api/properties/search',
            criteria,
          );
          return data;
        }
      } catch (error) {
        console.warn(
          'Backend property search request failed, using mock data:',
          error,
        );
      }

      // Fallback to mock data
      await new Promise((resolve) => setTimeout(resolve, SIMULATED_LATENCY));

      return properties.filter((property) => {
        if (criteria.minPrice && property.price < criteria.minPrice)
          return false;
        if (criteria.maxPrice && property.price > criteria.maxPrice)
          return false;
        if (criteria.beds && property.beds < criteria.beds) return false;
        if (criteria.baths && property.baths < criteria.baths) return false;
        if (
          criteria.neighborhood &&
          !property.neighborhood
            .toLowerCase()
            .includes(criteria.neighborhood.toLowerCase())
        )
          return false;
        if (
          criteria.schoolDistrict &&
          property.schoolDistrict !== criteria.schoolDistrict
        )
          return false;
        return true;
      });
    },

    /**
     * Get properties by badge type
     * Tries backend first if VITE_API_URL is set, falls back to mock data
     */
    getByBadge: async (badge: string): Promise<ExtendedProperty[]> => {
      try {
        // Try backend first if in backend mode
        if (API_CONFIG.isBackendMode) {
          const data = await apiClient.get<ExtendedProperty[]>(
            `/api/properties/badge/${encodeURIComponent(badge)}`,
          );
          return data;
        }
      } catch (error) {
        console.warn(
          'Backend property by badge request failed, using mock data:',
          error,
        );
      }

      // Fallback to mock data
      await new Promise((resolve) => setTimeout(resolve, SIMULATED_LATENCY));

      return properties.filter((property) =>
        property.badges.some((propertyBadge) =>
          propertyBadge.toLowerCase().includes(badge.toLowerCase()),
        ),
      );
    },
  },
};


[FILE_END: services\api.ts]
################################################################################

================================================================================
FILE_BEGIN: services\geminiService.ts
METADATA: Size=5932 bytes | Last_Modified=2026-01-06 09:13:55.926325
================================================================================
/**
 * Secure Client-Side Service for AI Operations
 * All sensitive operations are now handled server-side via proxy
 * This eliminates API key exposure vulnerabilities
 */

interface ApiResponse<T> {
  success: boolean;
  data?: T;
  message?: T; // For chat responses
  error?: string;
  code?: string;
  timestamp?: string;
}

interface ChatMessage {
  role: 'user' | 'model';
  parts: { text: string }[];
}

const API_BASE_URL = '/api';

// Input validation utilities
const validateBase64 = (base64Image: string): boolean => {
  if (typeof base64Image !== 'string') return false;
  const base64Regex = /^[A-Za-z0-9+/]*={0,2}$/;
  return base64Regex.test(base64Image) && base64Image.length > 0;
};

const validateMimeType = (mimeType: string): boolean => {
  const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'];
  return allowedTypes.includes(mimeType);
};

const sanitizeInput = (input: string): string => {
  if (typeof input !== 'string') return '';
  return input.replace(/[<>\"'&]/g, (match) => {
    const entities: Record<string, string> = {
      '<': '<',
      '>': '>',
      '"': '"',
      "'": '&#x27;',
      '&': '&',
    };
    return entities[match] || '';
  });
};

/**
 * Edits an image based on a text prompt using secure server proxy
 *
 * @param base64Image The source image in base64 format (without the data prefix).
 * @param mimeType The mime type of the image.
 * @param prompt The user's text instruction for editing.
 * @returns A promise resolving to the base64 data URI of the generated image.
 */
export const editImageWithGemini = async (
  base64Image: string,
  mimeType: string,
  prompt: string,
): Promise<string> => {
  try {
    // Input validation - CRITICAL for security
    if (!validateBase64(base64Image)) {
      throw new Error('Invalid image format');
    }

    if (!validateMimeType(mimeType)) {
      throw new Error('Unsupported image format');
    }

    if (!prompt || typeof prompt !== 'string') {
      throw new Error('Prompt is required');
    }

    if (prompt.length > 1000) {
      throw new Error('Prompt too long (max 1000 characters)');
    }

    // Sanitize inputs
    const sanitizedPrompt = sanitizeInput(prompt);
    const response = await fetch(`${API_BASE_URL}/ai/edit-image`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Requested-With': 'XMLHttpRequest',
      },
      body: JSON.stringify({
        base64Image,
        mimeType,
        prompt: sanitizedPrompt,
      }),
    });

    if (!response.ok) {
      const errorData: ApiResponse<null> = await response.json().catch(() => ({
        success: false,
        error: 'Server communication error',
      }));

      throw new Error(errorData.error || `HTTP ${response.status}`);
    }

    const result: ApiResponse<string> = await response.json();

    if (!result.success || !result.data) {
      throw new Error(result.error || 'Image processing failed');
    }
    return result.data;
  } catch (error) {
    console.error('Image edit error:', error);

    // Provide user-friendly error messages
    if (error instanceof TypeError && error.message.includes('fetch')) {
      throw new Error(
        'Unable to connect to AI service. Please try again later.',
      );
    }

    throw error;
  }
};

/**
 * Sends a chat message to Gemini via secure proxy
 *
 * @param message The user's message.
 * @param history The chat history.
 * @returns The model's text response.
 */
export const sendChatMessage = async (
  message: string,
  history: ChatMessage[] = [],
): Promise<string> => {
  try {
    // Input validation
    if (!message || typeof message !== 'string') {
      throw new Error('Message is required');
    }

    if (message.length > 4000) {
      throw new Error('Message too long (max 4000 characters)');
    }

    // Validate history format
    if (!Array.isArray(history)) {
      history = [];
    }

    // Sanitize message
    const sanitizedMessage = sanitizeInput(message);
    const response = await fetch(`${API_BASE_URL}/ai/chat`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Requested-With': 'XMLHttpRequest',
      },
      body: JSON.stringify({
        message: sanitizedMessage,
        history: history.map((msg) => ({
          role: msg.role,
          parts: [{ text: sanitizeInput(msg.parts[0]?.text || '') }],
        })),
      }),
    });

    if (!response.ok) {
      const errorData: ApiResponse<null> = await response.json().catch(() => ({
        success: false,
        error: 'Server communication error',
      }));

      throw new Error(errorData.error || `HTTP ${response.status}`);
    }

    const result: ApiResponse<string> = await response.json();

    if (!result.success || !result.message) {
      throw new Error(result.error || 'Chat processing failed');
    }
    return result.message;
  } catch (error) {
    console.error('Chat error:', error);

    // Provide user-friendly error messages
    if (error instanceof TypeError && error.message.includes('fetch')) {
      throw new Error(
        'Unable to connect to AI service. Please try again later.',
      );
    }

    throw error;
  }
};

/**
 * Health check for the AI service
 * @returns Promise<boolean> indicating service availability
 */
export const checkAiServiceHealth = async (): Promise<boolean> => {
  try {
    const response = await fetch(`${API_BASE_URL}/health`, {
      method: 'GET',
      headers: {
        'X-Requested-With': 'XMLHttpRequest',
      },
    });

    if (!response.ok) {
      return false;
    }

    const data = await response.json();
    return data.status === 'healthy';
  } catch (error) {
    console.error('Health check failed:', error);
    return false;
  }
};

// Export validation utilities for testing
export const validationUtils = {
  validateBase64,
  validateMimeType,
  sanitizeInput,
};


[FILE_END: services\geminiService.ts]
################################################################################

================================================================================
FILE_BEGIN: src\services\geminiService.ts
METADATA: Size=6343 bytes | Last_Modified=2026-01-07 07:19:35.972037
================================================================================
import {
  GoogleGenerativeAI,
  ChatSession as GoogleChatSession,
} from '@google/generative-ai';

// Initialize Google Generative AI with API key
// eslint-disable-next-line dot-notation
const apiKey =
  (import.meta.env as Record<string, string>)['VITE_GEMINI_API_KEY'] ||
  // eslint-disable-next-line dot-notation
  process.env['VITE_GEMINI_API_KEY'];

if (!apiKey) {
  // eslint-disable-next-line no-console
  console.warn(
    'Gemini API key not found. Set VITE_GEMINI_API_KEY in your environment variables.'
  );
}

const genAI = new GoogleGenerativeAI(apiKey || '');

interface Message {
  role: 'user' | 'model';
  text: string;
}

class GeminiService {
  private chatSession: GoogleChatSession | null = null;
  private isInitialized = false;

  /**
   * Initialize the Gemini service with the specified model
   */
  async initialize(): Promise<void> {
    if (this.isInitialized) return;

    try {
      // Use the cost-effective gemini-2.5-flash model
      const model = genAI.getGenerativeModel({
        model: 'gemini-2.5-flash',
        systemInstruction: {
          role: 'system',
          parts: [
            {
              text: `You are Patriot, a virtual concierge for Properties 4 Creation (P4C).
            Help veterans with housing/vouchers and their families find suitable homes.
            Your tone should be warm, professional, and supportive.
            Focus on providing helpful information about housing options,
            veteran resources, and the application process.
            You are knowledgeable about East Texas housing market and veteran benefits.`,
            },
          ],
        },
      });

      // Configure generation parameters for cost efficiency
      const generationConfig = {
        temperature: 0.7,
        topK: 1,
        topP: 1,
        maxOutputTokens: 250, // Limit tokens to save quota
        stopSequences: ['\n\n'],
      };

      this.chatSession = model.startChat({
        generationConfig,
        history: [],
      }) as GoogleChatSession;

      this.isInitialized = true;
      // eslint-disable-next-line no-console
    } catch (error) {
      // eslint-disable-next-line no-console
      console.error('Failed to initialize Gemini service:', error);
      throw new Error('Gemini service initialization failed');
    }
  }

  /**
   * Send a chat message to the Gemini model
   * @param message - The user's message
   * @returns Promise with the model's response
   */
  async sendChatMessage(message: string): Promise<string> {
    if (!this.isInitialized) {
      await this.initialize();
    }

    try {
      if (!this.chatSession) {
        throw new Error('Chat session not initialized');
      }

      const result = await this.chatSession.sendMessage(message);
      const response = result.response;
      const text = response.text();

      return text;
    } catch (error) {
      // eslint-disable-next-line no-console
      console.error('Error sending chat message:', error);

      // Return a helpful fallback message
      if (error instanceof Error) {
        if (error.message.includes('quota')) {
          return "I'm sorry, but I've reached my usage limit for today. Please try again later, or contact our team directly for assistance with your housing needs.";
        }
        if (error.message.includes('API key')) {
          return "I'm currently unable to access the AI service. Please try refreshing the page or contact our support team for assistance.";
        }
      }

      return "I apologize, but I'm experiencing technical difficulties. Please try your question again in a moment, or contact our team directly for immediate assistance with your housing needs.";
    }
  }

  /**
   * Edit an image with Gemini (placeholder for future implementation)
   * @param imageData - Base64 encoded image data (not used yet)
   * @param prompt - The editing prompt (not used yet)
   * @returns Promise with the edited image or error message
   */
  async editImageWithGemini(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _imageData: string,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _prompt: string
  ): Promise<string> {
    try {
      if (!this.isInitialized) {
        await this.initialize();
      }

      // Note: The gemini-2.5-flash model is primarily text-focused
      // For image editing, you would typically use gemini-pro-vision
      // This is a placeholder that returns a helpful message

      return `I'm currently unable to edit images directly. However, I can help you with:

      1. **Finding suitable properties** based on your preferences
      2. **Understanding veteran housing benefits** and how to apply for them
      3. **Guidance on the application process** for our properties
      4. **Information about available housing programs** in East Texas

      If you have a specific property image you'd like to discuss or need help with any housing-related questions, please let me know!`;
    } catch (error) {
      // eslint-disable-next-line no-console
      console.error('Error editing image:', error);
      return "I'm sorry, but I'm currently unable to process image editing requests. Please try again later or contact our team for assistance.";
    }
  }

  /**
   * Get the current chat history
   */
  async getChatHistory(): Promise<Message[]> {
    if (!this.chatSession) {
      return [];
    }

    try {
      const history = await this.chatSession.getHistory();
      return history.map((entry: any) => ({
        role: entry.role === 'user' ? 'user' : 'model',
        text: entry.parts[0]?.text || '',
      }));
    } catch (error) {
      // eslint-disable-next-line no-console
      console.error('Error getting chat history:', error);
      return [];
    }
  }

  /**
   * Clear the chat history
   */
  async clearChatHistory(): Promise<void> {
    if (this.chatSession) {
      try {
        // Restart the chat session to clear history
        await this.initialize();
      } catch (error) {
        // eslint-disable-next-line no-console
        console.error('Error clearing chat history:', error);
      }
    }
  }
}

// Export singleton instance
export const geminiService = new GeminiService();

// Export types for use in components
export type { Message };
export default geminiService;


[FILE_END: src\services\geminiService.ts]
################################################################################

================================================================================
FILE_BEGIN: types.ts
METADATA: Size=780 bytes | Last_Modified=2026-01-05 21:05:53.877940
================================================================================
export interface Property {
  id: string;
  title: string;
  address: string;
  price: number;
  beds: number;
  baths: number;
  sqft: number;
  imageUrl: string;
  badges: string[];
  description: string;
}

export interface TransformationData {
  beforeImage: string;
  afterImage: string;
  label: string;
}

export interface StatMetric {
  id: string;
  label: string;
  value: string;
  icon: 'users' | 'home' | 'hammer' | 'dollar' | 'heart';
  description?: string;
  trend?: 'up' | 'down' | 'neutral';
  trendValue?: string;
}

export interface RenovationStandard {
  id: string;
  category: string;
  standardLandlord: string;
  p4cStandard: string;
  benefit: string;
}

export interface FinancialBreakdown {
  category: string;
  percentage: number;
  color: string;
}


[FILE_END: types.ts]
################################################################################

================================================================================
FILE_BEGIN: utils\formatters.ts
METADATA: Size=2258 bytes | Last_Modified=2026-01-07 00:58:26.967934
================================================================================
/**
 * Utility functions for formatting data throughout the application
 */

/**
 * Formats a number as USD currency
 * @param amount - The amount to format
 * @param options - Intl.NumberFormat options
 * @returns Formatted currency string
 */
export const formatCurrency = (
  amount: number,
  options?: Intl.NumberFormatOptions,
): string => {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    minimumFractionDigits: 0,
    maximumFractionDigits: 0,
    ...options,
  }).format(amount);
};

/**
 * Formats a number with thousands separators
 * @param num - The number to format
 * @returns Formatted number string
 */
export const formatNumber = (num: number): string => {
  return new Intl.NumberFormat('en-US').format(num);
};

/**
 * Formats a date string to a human-readable format
 * @param dateString - ISO date string
 * @param options - Intl.DateTimeFormat options
 * @returns Formatted date string
 */
export const formatDate = (
  dateString: string,
  options?: Intl.DateTimeFormatOptions,
): string => {
  const date = new Date(dateString);
  return new Intl.DateTimeFormat('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    ...options,
  }).format(date);
};

/**
 * Truncates text to a specified length with ellipsis
 * @param text - The text to truncate
 * @param maxLength - Maximum length before truncation
 * @returns Truncated text with ellipsis if needed
 */
export const truncateText = (text: string, maxLength: number): string => {
  if (text.length <= maxLength) return text;
  return `${text.slice(0, maxLength)}...`;
};

/**
 * Generates initials from a name
 * @param name - Full name
 * @returns Initials string
 */
export const getInitials = (name: string): string => {
  return name
    .split(' ')
    .map((part) => part[0])
    .join('')
    .toUpperCase()
    .slice(0, 2);
};

/**
 * Slugifies a string for URLs
 * @param text - The text to slugify
 * @returns URL-safe slug string
 */
export const slugify = (text: string): string => {
  return text
    .toLowerCase()
    .replace(/[^\w\s-]/g, '')
    .replace(/\s+/g, '-')
    .replace(/--+/g, '-')
    .trim();
};


[FILE_END: utils\formatters.ts]
################################################################################

================================================================================
FILE_BEGIN: utils\imageOptimization.ts
METADATA: Size=5349 bytes | Last_Modified=2026-01-07 07:17:56.820341
================================================================================
/**
 * Image Optimization Utilities
 * Supports WebP/AVIF format detection and conversion
 */

export interface ImageFormat {
  webp: boolean;
  avif: boolean;
  original: string;
}

export interface OptimizedImageConfig {
  quality: number;
  progressive: boolean;
  lossy: boolean;
  effort: number;
}

export interface ResponsiveImageConfig {
  breakpoints: number[];
  formats: ('webp' | 'avif' | 'jpeg' | 'png')[];
  quality: number;
  sizes: string[];
}

// Check browser support for modern image formats
export const detectImageFormatSupport = (): ImageFormat => {
  const webp = checkWebPSupport();
  const avif = checkAVIFSupport();

  return {
    webp,
    avif,
    original: 'jpeg',
  };
};

// Check WebP support
const checkWebPSupport = (): boolean => {
  const canvas = document.createElement('canvas');
  canvas.width = 1;
  canvas.height = 1;
  return canvas.toDataURL('image/webp').indexOf('data:image/webp') === 0;
};

// Check AVIF support
const checkAVIFSupport = (): boolean => {
  const canvas = document.createElement('canvas');
  canvas.width = 1;
  canvas.height = 1;
  return canvas.toDataURL('image/avif').indexOf('data:image/avif') === 0;
};

// Get optimal image format based on browser support
export const getOptimalImageFormat = (
  formats: ImageFormat,
): 'avif' | 'webp' | 'jpeg' => {
  if (formats.avif) return 'avif';
  if (formats.webp) return 'webp';
  return 'jpeg';
};

// Generate responsive image srcset
export const generateResponsiveSrcset = (
  baseUrl: string,
  widths: number[],
  format: 'avif' | 'webp' | 'jpeg' = 'webp',
): string =>
  widths
    .map((width) => {
      const url = `${baseUrl}-${width}w.${format}`;
      return `${url} ${width}w`;
    })
    .join(', ');

// Generate optimized image URL
export const generateOptimizedImageUrl = (
  baseUrl: string,
  options: {
    width?: number;
    height?: number;
    quality?: number;
    format?: 'avif' | 'webp' | 'jpeg';
    blur?: boolean;
  } = {},
): string => {
  const {
    width,
    height,
    quality = 80,
    format = 'webp',
    blur = false,
  } = options;

  const params = new URLSearchParams();
  if (width) params.set('w', width.toString());
  if (height) params.set('h', height.toString());
  if (quality !== 80) params.set('q', quality.toString());
  if (blur) params.set('blur', '50');

  const formatParam = format === 'jpeg' ? 'jpg' : format;
  return `${baseUrl}.${formatParam}${params.toString() ? `?${params.toString()}` : ''}`;
};

// Image lazy loading with intersection observer
export class LazyImageLoader {
  private observer: IntersectionObserver;
  private config: IntersectionObserverInit;

  constructor(
    callback?: (entries: IntersectionObserverEntry[]) => void,
    config: IntersectionObserverInit = {},
  ) {
    this.config = {
      rootMargin: '50px',
      threshold: 0.01,
      ...config,
    };

    this.observer = new IntersectionObserver(
      callback || this.handleIntersection.bind(this),
      this.config,
    );
  }

  observe(element: HTMLElement): void {
    this.observer.observe(element);
  }

  unobserve(element: HTMLElement): void {
    this.observer.unobserve(element);
  }

  disconnect(): void {
    this.observer.disconnect();
  }

  private handleIntersection(entries: IntersectionObserverEntry[]): void {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        const img = entry.target as HTMLImageElement;
        this.loadImage(img);
        this.unobserve(img);
      }
    });
  }

  private loadImage(img: HTMLImageElement): void {
    // eslint-disable-next-line dot-notation
    const src = img.dataset['src'];
    // eslint-disable-next-line dot-notation
    const srcset = img.dataset['srcset'];

    if (src) {
      img.src = src;
    }
    if (srcset) {
      img.srcset = srcset;
    }

    img.onload = () => {
      img.classList.add('loaded');
    };

    img.onerror = () => {
      img.classList.add('error');
    };
  }
}

// Image optimization configuration
export const imageOptimizationConfig: OptimizedImageConfig = {
  quality: 80,
  progressive: true,
  lossy: true,
  effort: 4,
};

// Responsive image configuration
export const responsiveImageConfig: ResponsiveImageConfig = {
  breakpoints: [320, 640, 768, 1024, 1280, 1536, 1920],
  formats: ['avif', 'webp', 'jpeg'],
  quality: 80,
  sizes: [
    '(max-width: 640px) 100vw',
    '(max-width: 768px) 100vw',
    '(max-width: 1024px) 100vw',
    '(max-width: 1280px) 100vw',
    '100vw',
  ],
};

// Preload critical images
export const preloadCriticalImages = (imageUrls: string[]): void => {
  imageUrls.forEach((url) => {
    const link = document.createElement('link');
    link.rel = 'preload';
    link.as = 'image';
    link.href = url;
    link.type = `image/${url.split('.').pop()}`;
    document.head.appendChild(link);
  });
};

// Generate blur placeholder for lazy loading
export const generateBlurPlaceholder = (): string =>
  // This would typically be handled by a build-time process
  // For now, return a simple data URL
  `data:image/svg+xml;base64,${btoa(`
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
      <defs>
        <filter id="blur">
          <feGaussianBlur stdDeviation="20" />
        </filter>
      </defs>
      <rect width="400" height="300" fill="#f0f0f0" filter="url(#blur)" />
    </svg>
  `)}`;


[FILE_END: utils\imageOptimization.ts]
################################################################################

================================================================================
FILE_BEGIN: vite.config.ts
METADATA: Size=4325 bytes | Last_Modified=2026-01-07 08:48:51.869571
================================================================================
import path from 'path';
import { defineConfig, loadEnv } from 'vite';
import react from '@vitejs/plugin-react';

interface EnvVariables {
  [key: string]: string;
}

export default defineConfig(({ mode }) => {
  const env = loadEnv(mode, '.', '') as EnvVariables;

  // GitHub Pages configuration
  const isProduction = mode === 'production';
  // eslint-disable-next-line dot-notation
  const repositoryName = env['VITE_REPOSITORY_NAME'] || '';
  // For custom domain (CNAME), use root path; for github.io pages, use repository path
  const base = isProduction
    ? repositoryName
      ? `/${repositoryName}/`
      : '/'
    : '/';

  return {
    base,
    server: {
      port: 3000,
      host: '0.0.0.0',
      headers: {
        // Security Headers - CRITICAL for XSS Protection
        'X-Frame-Options': 'DENY',
        'X-Content-Type-Options': 'nosniff',
        'Referrer-Policy': 'strict-origin-when-cross-origin',
        'Permissions-Policy': 'camera=(), microphone=(), geolocation=()',
        'Strict-Transport-Security':
          'mndax-age=31536000; includeSubDomains; preload',
        // Content Security Policy - XSS Prevention
        'Content-Security-Policy':
          "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; img-src 'self' data: https:; font-src 'self' https://fonts.gstatic.com; connect-src 'self' http://localhost:3001; frame-src 'none'; object-src 'none'; base-uri 'self'; form-action 'self'; upgrade-insecure-requests;",
      },
      proxy: {
        // Proxy API calls to secure server
        '/api': {
          target: 'http://localhost:3001',
          changeOrigin: true,
          secure: false,
          rewrite: (path) => path,
        },
      },
    },
    plugins: [
      react(),
      // Add PWA and compression plugins in production
      ...(mode === 'production'
        ? [
            // These would be added when dependencies are installed
            // VitePWA({...}),
            // viteCompression({algorithm: 'gzip'})
          ]
        : []),
    ],
    assetsInclude: ['**/*.bin', '**/*.json'], // Helps loading local TFJS models if needed
    define: {
      // REMOVED: API key exposure vulnerability (CRITICAL FIX)
      // API keys are now handled server-side only via proxy
      'process.env.NODE_ENV': JSON.stringify(mode),
      'process.env.VITE_API_BASE_URL': JSON.stringify('/api'),
    },
    resolve: {
      alias: {
        '@': path.resolve(__dirname, '.'),
      },
    },
    build: {
      target: 'es2020',
      sourcemap: mode !== 'production',
      minify: 'terser',
      cssMinify: true,
      // Performance optimizations
      rollupOptions: {
        output: {
          // Manual chunks for better caching
          manualChunks: {
            // React and React DOM together
            react: ['react', 'react-dom'],
            // Router
            router: ['react-router-dom'],
            // UI library
            ui: ['lucide-react'],
            // AI service
            ai: ['@google/generative-ai'],
            // Utils
            utils: ['react-helmet-async'],
          },
          // Optimize chunk file names
          chunkFileNames: 'js/[name]-[hash].js',
          assetFileNames: (assetInfo) => {
            if (/\.(png|jpe?g|gif|svg|webp)$/i.test(assetInfo.name || '')) {
              return 'images/[name]-[hash][extname]';
            }
            if (/\.(woff2?|eot|ttf|otf)$/i.test(assetInfo.name || '')) {
              return 'fonts/[name]-[hash][extname]';
            }
            return 'assets/[name]-[hash][extname]';
          },
        },
      },
      // Optimize terser options
      terserOptions: {
        compress: {
          drop_console: mode === 'production',
          pure_funcs:
            mode === 'production'
              ? ['console.log', 'console.info', 'console.debug']
              : [],
        },
      },
      // Chunk size warnings
      chunkSizeWarningLimit: 1000,
    },
    // Performance optimizations
    optimizeDeps: {
      include: [
        'react',
        'react-dom',
        'react-router-dom',
        'lucide-react',
        '@google/generative-ai',
      ],
    },
    // CSS optimizations
    css: {
      devSourcemap: mode !== 'production',
    },
  };
});


[FILE_END: vite.config.ts]
################################################################################
