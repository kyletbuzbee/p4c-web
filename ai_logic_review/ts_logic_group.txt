
================================================================================
FILE_BEGIN: constants\images.ts
TYPE: TS
SIZE: 8108 bytes
================================================================================
/**
 * Centralized Asset Registry
 * Maps application logic to physical file paths.
 *
 * Usage:
 * import { IMAGES } from '../constants/images';
 * <img src={IMAGES.BANNERS.HERO_HOME} alt="Home" />
 */

// Brand Assets
export const IMAGES = {
  LOGO: {
    PNG: '/images/logo/brand-logo.webp',
    SVG: '/images/logo/brand-logo.svg',
    WHITE_GOLD: '/images/logo/brand-logo-white-gold.svg',
  },

  // Page Hero Banners
  BANNERS: {
    // Home Page
    HERO_HOME: '/images/banners/hero-home-banner.webp',
    HERO_HOME_640: '/images/banners/hero-home-banner-640.webp',
    HERO_HOME_960: '/images/banners/hero-home-banner-960.webp',
    HERO_HOME_1280: '/images/banners/hero-home-banner-1280.webp',
    HERO_HOME_1920: '/images/banners/hero-home-banner-1920.webp',

    // About Page
    HERO_ABOUT: '/images/banners/hero-about-banner-1280.webp',
    HERO_ABOUT_640: '/images/banners/hero-about-banner-640.webp',
    HERO_ABOUT_960: '/images/banners/hero-about-banner-960.webp',
    HERO_ABOUT_1920: '/images/banners/hero-about-banner-1920.webp',
    HERO_ABOUT_US: '/images/banners/hero-about-us-banner.webp',
    HERO_ABOUT_1: '/images/banners/hero-about1-banner.webp',

    // Contact Page
    HERO_CONTACT: '/images/banners/hero-contact-banner.webp',
    HERO_CONTACT_640: '/images/banners/hero-contact-banner-640.webp',
    HERO_CONTACT_960: '/images/banners/hero-contact-banner-960.webp',
    HERO_CONTACT_1280: '/images/banners/hero-contact-banner-1280.webp',
    HERO_CONTACT_1920: '/images/banners/hero-contact-banner-1920.webp',

    // Impact Page
    HERO_IMPACT: '/images/banners/hero-impact_banner-640.avif',
    HERO_IMPACT_640: '/images/banners/hero-impact_banner-640.avif',
    HERO_IMPACT_960: '/images/banners/hero-impact_banner-960.avif',
    HERO_IMPACT_1280: '/images/banners/hero-impact_banner-1280.avif',
    HERO_IMPACT_1920: '/images/banners/hero-impact_banner-1920.avif',

    // Privacy Page
    HERO_PRIVACY: '/images/banners/hero-privacy-banner.webp',
    HERO_PRIVACY_640: '/images/banners/hero-privacy-banner-640.webp',
    HERO_PRIVACY_800: '/images/banners/hero-privacy-banner-800w.webp',
    HERO_PRIVACY_960: '/images/banners/hero-privacy-banner-960.webp',
    HERO_PRIVACY_1200: '/images/banners/hero-privacy-banner-1200w.webp',
    HERO_PRIVACY_1280: '/images/banners/hero-privacy-banner-1280.webp',
    HERO_PRIVACY_1600: '/images/banners/hero-privacy-banner-1600w.webp',
    HERO_PRIVACY_1920: '/images/banners/hero-privacy-banner-1920.webp',

    // Projects Page
    HERO_PROJECTS: '/images/banners/hero-projects-banner.webp',
    HERO_PROJECTS_640: '/images/banners/hero-projects-banner-640.webp',
    HERO_PROJECTS_960: '/images/banners/hero-projects-banner-960.webp',
    HERO_PROJECTS_1280: '/images/banners/hero-projects-banner-1280.webp',
    HERO_PROJECTS_1920: '/images/banners/hero-projects-banner-1920.webp',

    // Resources Page
    HERO_RESOURCES: '/images/banners/hero-resources-banner.webp',
    HERO_RESOURCES_640: '/images/banners/hero-resources-banner-640.webp',
    HERO_RESOURCES_960: '/images/banners/hero-resources-banner-960.webp',
    HERO_RESOURCES_1280: '/images/banners/hero-resources-banner-1280.webp',
    HERO_RESOURCES_1920: '/images/banners/hero-resources-banner-1920.webp',

    // Terms Page
    HERO_TERMS: '/images/banners/hero-terms-banner-1200w.webp',
    HERO_TERMS_800: '/images/banners/hero-terms-banner-800w.webp',

    // Transparency Page
    HERO_TRANSPARENCY: '/images/banners/hero-transparency-banner.webp',
    HERO_TRANSPARENCY_640: '/images/banners/hero-transparency-banner-640.webp',
    HERO_TRANSPARENCY_960: '/images/banners/hero-transparency-banner-960.webp',
    HERO_TRANSPARENCY_1280:
      '/images/banners/hero-transparency-banner-1280.webp',
    HERO_TRANSPARENCY_1920:
      '/images/banners/hero-transparency-banner-1920.webp',

    // Application Page
    HERO_APPLICATION: '/images/banners/hero-application-banner.webp',

    // FAQ Page
    HERO_FAQ: '/images/banners/hero-faq-banner.webp',

    // Get Started / Success Story Page
    HERO_SUCCESS_STORY: '/images/banners/hero-get-started-banner.webp',
    HERO_SUCCESS_STORY_640: '/images/banners/hero-get-started-banner-640.webp',
    HERO_SUCCESS_STORY_960: '/images/banners/hero-get-started-banner-960.webp',
    HERO_SUCCESS_STORY_1280:
      '/images/banners/hero-get-started-banner-1280.webp',
    HERO_SUCCESS_STORY_1920:
      '/images/banners/hero-get-started-banner-1920.webp',

    // Deprecated: Get Started renamed to Success Story
    HERO_GET_STARTED: '/images/banners/hero-get-started-banner.webp',

    // Legal Page
    HERO_LEGAL: '/images/banners/hero-legal-banner.webp',
    HERO_LEGAL_640: '/images/banners/hero-legal-banner-640.webp',
    HERO_LEGAL_960: '/images/banners/hero-legal-banner-960.webp',
    HERO_LEGAL_1280: '/images/banners/hero-legal-banner-1280.webp',
    HERO_LEGAL_1920: '/images/banners/hero-legal-banner-1920.webp',

    // Property Details Page
    HERO_PROPERTY: '/images/banners/hero-property-banner.webp',

    // Thank You Page
    HERO_THANK_YOU: '/images/banners/hero-thank-you-banner.webp',
  },

  // Property Listings
  PROPERTIES: {
    JEFFERSON_RIVER: '/images/properties/jefferson-riverfront.webp',
    KEMP_TOWNHOME: '/images/properties/kemp-townhome.webp',
    LINDALE_COTTAGE: '/images/properties/lindale-cottage.webp',
    LONGVIEW_VICTORIAN: '/images/properties/longview-victorian.webp',
    MARSHALL_FARMHOUSE: '/images/properties/marshall-farmhouse-400w.webp',
    MINEOLA_STUDIO: '/images/properties/mineola-studio.webp',
    MINEOLA_STUDIO_OUTSIDE: '/images/properties/mineola-studio-outside.webp',
    RODRIGUEZ_FAMILY: '/images/properties/rodriguez-family-400w.webp',
    TYLER_RANCH: '/images/properties/tyler-ranch-home.webp',
    TYLER_RANCH_400: '/images/properties/tyler-ranch-home-400w.webp',
  },

  // Team & About
  TEAM: {
    OWNER: '/images/about/about-us-team-owner.webp',
    HEADSHOT: '/images/about/about-us-team-headshot.webp',
    ONSITE: '/images/about/about-us-team-onsite.webp',
  },

  // Renovation Showcase (Before/After)
  RENOVATION: {
    BATHROOM: {
      BEFORE:
        '/images/before-after-comparison/projects-before-bathroom-800w.webp',
      AFTER:
        '/images/before-after-comparison/projects-after-bathroom-800w.webp',
    },
    KITCHEN: {
      BEFORE:
        '/images/before-after-comparison/projects-before-kitchen-800w.webp',
      AFTER: '/images/before-after-comparison/projects-after-kitchen-800w.webp',
    },
    LIVING_ROOM: {
      BEFORE:
        '/images/before-after-comparison/projects-before-living-room-800w.webp',
      AFTER:
        '/images/before-after-comparison/projects-after-living-room-800w.webp',
    },
    FRONT_PORCH: {
      BEFORE:
        '/images/before-after-comparison/projects-before-front-porch-400w.webp',
      AFTER:
        '/images/before-after-comparison/projects-after-front-porch-800w.webp',
    },
    BRICK_PATIO: {
      BEFORE:
        '/images/before-after-comparison/projects-before-brick-patio-400w.webp',
      AFTER:
        '/images/before-after-comparison/projects-after-brick-patio-400w.webp',
    },
  },

  // Gallery / Our Work
  GALLERY: {
    FRAMING: '/images/our-work-gallery/our-work-framing-door.webp',
    PAINTING: '/images/our-work-gallery/our-work-painting-dog-800w.webp',
    MEASURING: '/images/our-work-gallery/our-work-detailed-measuring-800w.webp',
    REMODELING: '/images/our-work-gallery/our-work-remodeling-400w.webp',
    BUY_AS_IS: '/images/our-work-gallery/our-impact-buy-as-is.webp',
    LINDALE_COTTAGE: '/images/our-work-gallery/lindale-cottage-before.webp',
    WORK_FRAMING_DOOR: '/images/our-work-gallery/work-framing-door.webp',
    PROJECTS_AFTER_LIVING_ROOM:
      '/images/our-work-gallery/projects-after-living-room.webp',
  },

  // Videos
  VIDEOS: {
    HOME: '/images/videos/home.mp4',
    HERO_PROJECTS: '/images/videos/hero-projects-banner.mp4',
    HERO_WORK: '/images/videos/hero-our-work-banner.mp4',
    HERO_IMPACT: '/images/videos/hero-our-impact.mp4',
    SUCCESS_STORY: '/images/videos/success-story.mp4',
  },
} as const;


[FILE_END: constants\images.ts]
################################################################################

================================================================================
FILE_BEGIN: data\properties.ts
TYPE: TS
SIZE: 5141 bytes
================================================================================
import type { ExtendedProperty } from '../types';
import { IMAGES } from '../constants/images';

// Re-export ExtendedProperty type for backward compatibility
export type { ExtendedProperty };

export const properties: ExtendedProperty[] = [
  {
    id: '1',
    title: 'The Magnolia Residence',
    address: '1245 Oakwood Dr, Tyler, TX',
    price: 950,
    beds: 3,
    baths: 2,
    sqft: 1450,
    imageUrl: IMAGES.PROPERTIES.TYLER_RANCH,
    badges: ['Section 8 Approved', 'Wheelchair Accessible'],
    description:
      'Fully renovated single-family home featuring quartz countertops, new HVAC, and a spacious fenced backyard perfect for families. Located within walking distance of Douglas Elementary School.',
    amenities: [
      'Quartz Countertops',
      'Fenced Backyard',
      'Central HVAC',
      'Dishwasher',
      'Washer/Dryer Hookups',
    ],
    accessibilityFeatures: [
      'Wheelchair Ramp',
      'Wide Doorways (36")',
      'Grab Bars in Bathroom',
    ],
    schoolDistrict: 'Tyler ISD',
    neighborhood: 'Azalea District',
    availabilityDate: 'Available Now',
    coordinates: { lat: 32.3513, lng: -95.3011 },
  },
  {
    id: '2',
    title: 'Veterans Harbor',
    address: '880 Pine Street, Longview, TX',
    price: 875,
    beds: 2,
    baths: 1.5,
    sqft: 1100,
    imageUrl: IMAGES.PROPERTIES.MINEOLA_STUDIO,
    badges: ['HUD-VASH Preferred', 'Near VA Clinic'],
    description:
      'Cozy bungalow tailored for veterans. Includes walk-in shower, energy-efficient appliances, and dedicated parking. Quiet neighborhood with community garden nearby.',
    amenities: [
      'Energy Star Appliances',
      'Dedicated Parking',
      'Community Garden Access',
      'Security System',
    ],
    accessibilityFeatures: [
      'Step-free Entrance',
      'Roll-in Shower',
      'Lever Handles',
    ],
    schoolDistrict: 'Longview ISD',
    neighborhood: 'Pine Tree',
    availabilityDate: 'October 15, 2023',
    coordinates: { lat: 32.5007, lng: -94.7405 },
  },
  {
    id: '3',
    title: 'Creekview Estate',
    address: '300 Cedar Lane, Marshall, TX',
    price: 1100,
    beds: 4,
    baths: 2,
    sqft: 1800,
    imageUrl: IMAGES.PROPERTIES.MARSHALL_FARMHOUSE,
    badges: ['Fenced Yard', 'New Roof'],
    description:
      'Spacious family home with open floor plan. Brand new luxury vinyl plank flooring throughout and modernized kitchen. Features a covered patio and detached garage.',
    amenities: [
      'LVP Flooring',
      'Covered Patio',
      'Detached Garage',
      'Walk-in Closets',
    ],
    accessibilityFeatures: ['Flat Thresholds'],
    schoolDistrict: 'Marshall ISD',
    neighborhood: 'Historic District',
    availabilityDate: 'November 1, 2023',
    coordinates: { lat: 32.5449, lng: -94.3674 },
  },
  {
    id: '4',
    title: 'Liberty Row',
    address: '405 Freedom Blvd, Tyler, TX',
    price: 1050,
    beds: 3,
    baths: 2,
    sqft: 1600,
    imageUrl: IMAGES.PROPERTIES.LONGVIEW_VICTORIAN,
    badges: ['New Construction', 'Energy Star'],
    description:
      'A complete restoration project turned modern sanctuary. Open concept living area, LED lighting throughout, and a brand new thermal insulation package to keep utility bills low.',
    amenities: [
      'LED Lighting',
      'Smart Thermostat',
      'Thermal Insulation',
      'Open Concept',
    ],
    accessibilityFeatures: ['Accessible Parking'],
    schoolDistrict: 'Tyler ISD',
    neighborhood: 'Downtown Tyler',
    availabilityDate: 'Available Now',
    coordinates: { lat: 32.3513, lng: -95.3011 },
  },
  {
    id: '5',
    title: 'The Patriot Duplex',
    address: '220 Victory Lane, Kilgore, TX',
    price: 825,
    beds: 2,
    baths: 1,
    sqft: 950,
    imageUrl: IMAGES.PROPERTIES.KEMP_TOWNHOME,
    badges: ['Rapid Rehousing', 'Pet Friendly'],
    description:
      'Affordable duplex unit recently updated with fresh paint and new appliances. Large shared yard and close to public transit routes.',
    amenities: ['Fresh Paint', 'Shared Yard', 'Pet Friendly', 'Transit Access'],
    accessibilityFeatures: ['Ground Floor Unit'],
    schoolDistrict: 'Kilgore ISD',
    neighborhood: 'Sycamore Grove',
    availabilityDate: 'Waitlist Open',
    coordinates: { lat: 32.3852, lng: -94.8767 },
  },
  {
    id: '6',
    title: 'Freedom Heights',
    address: '1500 Independence Dr, Lindale, TX',
    price: 1250,
    beds: 3,
    baths: 2.5,
    sqft: 1750,
    imageUrl: IMAGES.PROPERTIES.LINDALE_COTTAGE,
    badges: ['Family Size', 'Top Rated Schools'],
    description:
      'Beautiful brick home in the highly sought-after Lindale school district. Features a double vanity, large soaking tub, and a fireplace for cozy evenings.',
    amenities: ['Fireplace', 'Double Vanity', 'Soaking Tub', 'Brick Exterior'],
    accessibilityFeatures: ['Paved Walkways'],
    schoolDistrict: 'Lindale ISD',
    neighborhood: 'Eagle Creek',
    availabilityDate: 'December 1, 2023',
    coordinates: { lat: 32.5165, lng: -95.4093 },
  },
];

export const getPropertyById = (
  id: string | undefined
): ExtendedProperty | undefined => properties.find((p) => p.id === id);


[FILE_END: data\properties.ts]
################################################################################

================================================================================
FILE_BEGIN: p4c-web\services\botpressWebchatService.ts
TYPE: TS
SIZE: 5011 bytes
================================================================================
/**
 * Botpress Webchat Service
 * Service for embedding Botpress webchat directly in React components
 * This approach uses the existing working Botpress Cloud setup
 */

import { logError } from './errorBoundaryService';

interface WebchatConfig {
  configUrl?: string;
  width?: string;
  height?: string;
}

const BOTPRESS_WEBCHAT_URL =
  'https://cdn.botpress.cloud/webchat/v3.5/shareable.html';
const BOTPRESS_CONFIG_URL =
  'https://files.bpcontent.cloud/2025/10/13/00/20251013003640-UG466F0L.json';

/**
 * Initialize Botpress webchat
 * This embeds the Botpress webchat directly into a container element
 *
 * @param containerId The ID of the HTML element to embed the webchat in
 * @param config Configuration options for the webchat
 */
export const initializeBotpressWebchat = (
  containerId: string,
  config: WebchatConfig = {}
): void => {
  try {
    // Check if webchat is already initialized
    if (document.getElementById(`bp-webchat-${containerId}`)) {
      console.warn(
        'Botpress webchat already initialized for container:',
        containerId
      );
      return;
    }

    const container = document.getElementById(containerId);
    if (!container) {
      throw new Error(`Container element with ID '${containerId}' not found`);
    }

    // Create iframe for Botpress webchat
    const iframe = document.createElement('iframe');
    iframe.id = `bp-webchat-${containerId}`;
    iframe.src = `${BOTPRESS_WEBCHAT_URL}?configUrl=${encodeURIComponent(BOTPRESS_CONFIG_URL)}`;
    iframe.width = config.width || '100%';
    iframe.height = config.height || '100%';
    iframe.style.border = 'none';
    iframe.style.borderRadius = '12px';
    iframe.style.boxShadow = '0 10px 25px rgba(0, 0, 0, 0.1)';
    iframe.allow = 'microphone *; camera *; autoplay *';
    iframe.title = 'Properties 4 Creation Virtual Assistant';

    // Add loading state
    container.innerHTML = `
      <div class="flex items-center justify-center h-full bg-gray-50 rounded-2xl">
        <div class="text-center">
          <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-p4c-gold mx-auto mb-2"></div>
          <p class="text-sm text-gray-600">Loading Patriot...</p>
        </div>
      </div>
    `;

    // Handle iframe load
    iframe.onload = () => {
      // Clear loading state
      container.innerHTML = '';
      container.appendChild(iframe);
    };

    // Handle iframe errors
    iframe.onerror = (error) => {
      logError('Botpress webchat iframe failed to load', {
        error: error instanceof Error ? error : new Error(String(error)),
        component: 'botpressWebchatService',
        containerId,
      });

      container.innerHTML = `
        <div class="flex items-center justify-center h-full bg-red-50 rounded-2xl p-4">
          <div class="text-center">
            <div class="text-red-500 mb-2">⚠️</div>
            <p class="text-sm text-red-700">Failed to load assistant</p>
            <button
              onclick="window.location.reload()"
              class="mt-2 px-3 py-1 bg-red-500 text-white text-xs rounded hover:bg-red-600 transition-colors"
            >
              Retry
            </button>
          </div>
        </div>
      `;
    };

    // Set a timeout in case iframe doesn't load
    setTimeout(() => {
      if (container.querySelector('.animate-spin')) {
        if (iframe.onload) {
          iframe.onload(new Event('load'));
        }
      }
    }, 5000);
  } catch (error) {
    logError('Failed to initialize Botpress webchat', {
      error: error as Error,
      component: 'botpressWebchatService',
      containerId,
    });

    throw error;
  }
};

/**
 * Destroy Botpress webchat instance
 * Cleans up the webchat from a container
 *
 * @param containerId The ID of the container to clean up
 */
export const destroyBotpressWebchat = (containerId: string): void => {
  try {
    const iframe = document.getElementById(`bp-webchat-${containerId}`);
    if (iframe) {
      iframe.remove();
    }

    const container = document.getElementById(containerId);
    if (container) {
      container.innerHTML = '';
    }
  } catch (error) {
    logError('Failed to destroy Botpress webchat', {
      error: error as Error,
      component: 'botpressWebchatService',
      containerId,
    });
  }
};

/**
 * Check if Botpress webchat is available
 * Returns true if the webchat URL is accessible
 */
export const checkBotpressWebchatHealth = (): boolean => {
  try {
    // Simple check - in a real implementation you might ping the config URL
    // For now, we'll assume it's available since it's a CDN URL
    return true;
  } catch (error) {
    logError('Botpress webchat health check failed', {
      error: error instanceof Error ? error : new Error(String(error)),
      component: 'botpressWebchatService',
    });
    return false;
  }
};

// Default export for backward compatibility
export default {
  initializeBotpressWebchat,
  destroyBotpressWebchat,
  checkBotpressWebchatHealth,
};


[FILE_END: p4c-web\services\botpressWebchatService.ts]
################################################################################

================================================================================
FILE_BEGIN: services\api.ts
TYPE: TS
SIZE: 10849 bytes
================================================================================
import type {
  StatMetric,
  RenovationStandard,
  FinancialBreakdown,
  ExtendedProperty,
} from '../types';
import { properties, getPropertyById } from '../data/properties';

/**
 * Enhanced Backend API Service
 *
 * This service supports both development (mock data) and production (real backend) modes.
 *
 * Development Mode (Default):
 * - Uses mock data with simulated network latency
 * - No environment variables required
 * - Perfect for frontend development and testing
 *
 * Production Mode:
 * - Set VITE_API_URL environment variable to enable real backend integration
 * - Falls back to mock data if backend is unavailable
 * - Automatic switching based on environment configuration
 *
 * Environment Setup:
 * - Copy .env.example to .env and configure VITE_API_URL
 * - Development: Leave VITE_API_URL empty (uses mock data)
 * - Production: Set VITE_API_URL to your backend endpoint
 */

const SIMULATED_LATENCY = 800; // ms

// Environment configuration for backend integration
const API_CONFIG = {
  // Get API URL from environment variable, fallback to empty string for mock data
  // eslint-disable-next-line dot-notation
  baseUrl: import.meta.env['VITE_API_URL'] || '',

  // Check if we're in backend mode (has API URL) or mock mode (no API URL)
  get isBackendMode() {
    return this.baseUrl.trim().length > 0;
  },

  // Get full API endpoint URL
  getEndpointUrl(endpoint: string): string {
    return `${this.baseUrl.replace(/\/$/, '')}${endpoint.startsWith('/') ? endpoint : `/${endpoint}`}`;
  },
};

/**
 * HTTP client for backend communication
 * Automatically falls back to mock data on network errors
 */
class ApiClient {
  private async makeRequest<T>(
    endpoint: string,
    options?: RequestInit
  ): Promise<T> {
    if (!API_CONFIG.isBackendMode) {
      throw new Error('Backend mode disabled - using mock data');
    }

    try {
      const url = API_CONFIG.getEndpointUrl(endpoint);
      const response = await fetch(url, {
        headers: {
          'Content-Type': 'application/json',
          ...options?.headers,
        },
        ...options,
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      return await response.json();
    } catch {
      throw new Error('Backend unavailable - using mock data');
    }
  }

  get<T>(endpoint: string): Promise<T> {
    return this.makeRequest<T>(endpoint, { method: 'GET' });
  }

  post<T>(endpoint: string, data?: unknown): Promise<T> {
    return this.makeRequest<T>(endpoint, {
      method: 'POST',
      body: data ? JSON.stringify(data) : null,
    });
  }
}

const apiClient = new ApiClient();

export const api = {
  impact: {
    /**
     * Get impact metrics
     * Tries backend first if VITE_API_URL is set, falls back to mock data
     */
    getMetrics: async (): Promise<StatMetric[]> => {
      try {
        // Try backend first if in backend mode
        if (API_CONFIG.isBackendMode) {
          const data = await apiClient.get<StatMetric[]>('/api/impact/metrics');
          return data;
        }
      } catch {
        // Fallback to mock data
      }

      // Fallback to mock data
      await new Promise((resolve) => setTimeout(resolve, SIMULATED_LATENCY));
      return [
        {
          id: '1',
          label: 'Families Housed',
          value: '142',
          icon: 'home',
          description: 'Total families placed in safe, renovated homes.',
          trend: 'up',
          trendValue: '+12% this year',
        },
        {
          id: '2',
          label: 'Veterans Served',
          value: '85',
          icon: 'users',
          description: 'Veterans housed via HUD-VASH or direct placement.',
          trend: 'up',
          trendValue: '+8% this year',
        },
        {
          id: '3',
          label: 'Properties Revitalized',
          value: '56',
          icon: 'hammer',
          description: 'Distressed properties fully renovated.',
          trend: 'up',
          trendValue: '+5 this quarter',
        },
        {
          id: '4',
          label: 'Community Wealth',
          value: '$2.4M',
          icon: 'dollar',
          description: 'Estimated property value added to local neighborhoods.',
          trend: 'up',
          trendValue: 'Est. Value',
        },
      ];
    },

    /**
     * Get financial breakdown
     * Tries backend first if VITE_API_URL is set, falls back to mock data
     */
    getFinancialBreakdown: async (): Promise<FinancialBreakdown[]> => {
      try {
        // Try backend first if in backend mode
        if (API_CONFIG.isBackendMode) {
          const data = await apiClient.get<FinancialBreakdown[]>(
            '/api/impact/financial-breakdown'
          );
          return data;
        }
      } catch {
        // Fallback to mock data
      }

      // Fallback to mock data
      await new Promise((resolve) => setTimeout(resolve, SIMULATED_LATENCY));
      return [
        { category: 'Property Maintenance', percentage: 35, color: '#0B1120' },
        { category: 'Future Acquisitions', percentage: 30, color: '#C5A059' },
        { category: 'Investor Returns', percentage: 20, color: '#334155' },
        { category: 'Community Programs', percentage: 10, color: '#94a3b8' },
        { category: 'Admin/Ops', percentage: 5, color: '#cbd5e1' },
      ];
    },
  },

  transparency: {
    /**
     * Get renovation standards
     * Tries backend first if VITE_API_URL is set, falls back to mock data
     */
    getStandards: async (): Promise<RenovationStandard[]> => {
      try {
        // Try backend first if in backend mode
        if (API_CONFIG.isBackendMode) {
          const data = await apiClient.get<RenovationStandard[]>(
            '/api/transparency/standards'
          );
          return data;
        }
      } catch {
        // Fallback to mock data
      }

      // Fallback to mock data
      await new Promise((resolve) => setTimeout(resolve, SIMULATED_LATENCY));
      return [
        {
          id: 'kitchen',
          category: 'Kitchen Countertops',
          standardLandlord: 'Laminate / Formica',
          p4cStandard: 'Quartz or Granite',
          benefit: 'Hygienic, durable, heat resistant, and dignified.',
        },
        {
          id: 'flooring',
          category: 'Flooring',
          standardLandlord: 'Cheap Carpet or Sheet Vinyl',
          p4cStandard: 'Luxury Vinyl Plank (LVP)',
          benefit:
            'Waterproof, allergen-free, pet-friendly, and lasts 10+ years.',
        },
        {
          id: 'hvac',
          category: 'Climate Control',
          standardLandlord: 'Repair old units until failure',
          p4cStandard: 'New High-Efficiency SEER 16+',
          benefit:
            'Lowers tenant utility bills by ~25% and ensures reliability.',
        },
        {
          id: 'security',
          category: 'Security',
          standardLandlord: 'Standard deadbolt',
          p4cStandard: 'Smart Locks + Motion Lighting',
          benefit: 'Enhanced safety for families and peace of mind.',
        },
      ];
    },
  },

  properties: {
    /**
     * Get all available properties
     * Tries backend first if VITE_API_URL is set, falls back to mock data
     */
    getAll: async (): Promise<ExtendedProperty[]> => {
      try {
        // Try backend first if in backend mode
        if (API_CONFIG.isBackendMode) {
          const data =
            await apiClient.get<ExtendedProperty[]>('/api/properties');
          return data;
        }
      } catch {
        // Fallback to mock data
      }

      // Fallback to mock data
      await new Promise((resolve) => setTimeout(resolve, SIMULATED_LATENCY));
      return properties;
    },

    /**
     * Get a specific property by ID
     * Tries backend first if VITE_API_URL is set, falls back to mock data
     */
    getById: async (id: string): Promise<ExtendedProperty | null> => {
      try {
        // Try backend first if in backend mode
        if (API_CONFIG.isBackendMode) {
          const data = await apiClient.get<ExtendedProperty>(
            `/api/properties/${id}`
          );
          return data;
        }
      } catch {
        // Fallback to mock data
      }

      // Fallback to mock data
      await new Promise((resolve) => setTimeout(resolve, SIMULATED_LATENCY));
      const property = getPropertyById(id);
      return property || null;
    },

    /**
     * Search properties by criteria
     * Tries backend first if VITE_API_URL is set, falls back to mock data
     */
    search: async (criteria: {
      minPrice?: number;
      maxPrice?: number;
      beds?: number;
      baths?: number;
      neighborhood?: string;
      schoolDistrict?: string;
    }): Promise<ExtendedProperty[]> => {
      try {
        // Try backend first if in backend mode
        if (API_CONFIG.isBackendMode) {
          const data = await apiClient.post<ExtendedProperty[]>(
            '/api/properties/search',
            criteria
          );
          return data;
        }
      } catch {
        // Fallback to mock data
      }

      // Fallback to mock data
      await new Promise((resolve) => setTimeout(resolve, SIMULATED_LATENCY));

      return properties.filter((property) => {
        if (criteria.minPrice && property.price < criteria.minPrice)
          return false;
        if (criteria.maxPrice && property.price > criteria.maxPrice)
          return false;
        if (criteria.beds && property.beds < criteria.beds) return false;
        if (criteria.baths && property.baths < criteria.baths) return false;
        if (
          criteria.neighborhood &&
          !property.neighborhood
            .toLowerCase()
            .includes(criteria.neighborhood.toLowerCase())
        )
          return false;
        if (
          criteria.schoolDistrict &&
          property.schoolDistrict !== criteria.schoolDistrict
        )
          return false;
        return true;
      });
    },

    /**
     * Get properties by badge type
     * Tries backend first if VITE_API_URL is set, falls back to mock data
     */
    getByBadge: async (badge: string): Promise<ExtendedProperty[]> => {
      try {
        // Try backend first if in backend mode
        if (API_CONFIG.isBackendMode) {
          const data = await apiClient.get<ExtendedProperty[]>(
            `/api/properties/badge/${encodeURIComponent(badge)}`
          );
          return data;
        }
      } catch {
        // Fallback to mock data
      }

      // Fallback to mock data
      await new Promise((resolve) => setTimeout(resolve, SIMULATED_LATENCY));

      return properties.filter((property) =>
        property.badges.some((propertyBadge) =>
          propertyBadge.toLowerCase().includes(badge.toLowerCase())
        )
      );
    },
  },
};


[FILE_END: services\api.ts]
################################################################################

================================================================================
FILE_BEGIN: services\botpressService.test.ts
TYPE: TS
SIZE: 5245 bytes
================================================================================
/**
 * Botpress Service Tests
 * Unit tests for the Botpress service layer
 */

import { describe, it, expect, vi, beforeEach } from 'vitest';
import {
  sendChatMessage,
  checkBotpressHealth,
  validationUtils,
} from './botpressService';

// Mock the global fetch function
global.fetch = vi.fn();

describe('Botpress Service', () => {
  beforeEach(() => {
    fetch.mockClear();
  });

  describe('validationUtils', () => {
    const { validateBase64, validateMimeType, sanitizeInput } = validationUtils;

    describe('validateBase64', () => {
      it('should return true for valid base64 strings', () => {
        expect(validateBase64('SGVsbG8gd29ybGQ=')).toBe(true);
        expect(validateBase64('aGVsbG8=')).toBe(true);
        expect(validateBase64('aGVsbG8gd29ybGQ=')).toBe(true);
      });

      it('should return false for invalid base64 strings', () => {
        expect(validateBase64('not-base64')).toBe(false);
        expect(validateBase64('')).toBe(false);
        expect(validateBase64('SGVsbG8gd29ybGQ!')).toBe(false);
      });

      it('should return false for non-string inputs', () => {
        expect(validateBase64(123 as any)).toBe(false);
        expect(validateBase64(null as any)).toBe(false);
        expect(validateBase64(undefined as any)).toBe(false);
      });
    });

    describe('validateMimeType', () => {
      it('should return true for allowed image mime types', () => {
        expect(validateMimeType('image/jpeg')).toBe(true);
        expect(validateMimeType('image/jpg')).toBe(true);
        expect(validateMimeType('image/png')).toBe(true);
        expect(validateMimeType('image/webp')).toBe(true);
      });

      it('should return false for disallowed mime types', () => {
        expect(validateMimeType('image/gif')).toBe(false);
        expect(validateMimeType('image/svg+xml')).toBe(false);
        expect(validateMimeType('application/pdf')).toBe(false);
      });
    });

    describe('sanitizeInput', () => {
      it('should sanitize HTML special characters', () => {
        expect(sanitizeInput('<script>alert("xss")</script>')).toBe(
          '<script>alert("xss")</script>'
        );
        expect(sanitizeInput('Hello & goodbye')).toBe('Hello & goodbye');
        expect(sanitizeInput("'single quotes'")).toBe(
          '&#x27;single quotes&#x27;'
        );
      });

      it('should return empty string for non-string inputs', () => {
        expect(sanitizeInput(123 as any)).toBe('');
        expect(sanitizeInput(null as any)).toBe('');
        expect(sanitizeInput(undefined as any)).toBe('');
      });
    });
  });

  describe('sendChatMessage', () => {
    it('should throw error for empty message', async () => {
      await expect(sendChatMessage('')).rejects.toThrow('Message is required');
    });

    it('should throw error for message that is too long', async () => {
      const longMessage = 'a'.repeat(4001);
      await expect(sendChatMessage(longMessage)).rejects.toThrow(
        'Message too long (max 4000 characters)'
      );
    });

    it('should call the API with correct parameters', async () => {
      const mockResponse = {
        success: true,
        message: 'Hello from Botpress!',
        timestamp: new Date().toISOString(),
      };

      fetch.mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve(mockResponse),
      });

      const result = await sendChatMessage('Hello');

      expect(fetch).toHaveBeenCalledWith('/api/ai/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Requested-With': 'XMLHttpRequest',
        },
        body: JSON.stringify({
          message: 'Hello',
          history: [],
        }),
      });

      expect(result).toBe('Hello from Botpress!');
    });

    it('should handle API errors gracefully', async () => {
      fetch.mockResolvedValueOnce({
        ok: false,
        status: 500,
        json: () => Promise.resolve({ error: 'Internal server error' }),
      });

      await expect(sendChatMessage('Hello')).rejects.toThrow(
        'Internal server error'
      );
    });

    it('should handle network errors gracefully', async () => {
      fetch.mockRejectedValueOnce(new TypeError('Failed to fetch'));

      await expect(sendChatMessage('Hello')).rejects.toThrow(
        'Unable to connect to AI service. Please try again later.'
      );
    });
  });

  describe('checkBotpressHealth', () => {
    it('should return true for healthy service', async () => {
      const mockResponse = {
        status: 'healthy',
      };

      fetch.mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve(mockResponse),
      });

      const result = await checkBotpressHealth();
      expect(result).toBe(true);
    });

    it('should return false for unhealthy service', async () => {
      fetch.mockResolvedValueOnce({
        ok: false,
      });

      const result = await checkBotpressHealth();
      expect(result).toBe(false);
    });

    it('should return false on network error', async () => {
      fetch.mockRejectedValueOnce(new Error('Network error'));

      const result = await checkBotpressHealth();
      expect(result).toBe(false);
    });
  });
});


[FILE_END: services\botpressService.test.ts]
################################################################################

================================================================================
FILE_BEGIN: services\botpressService.ts
TYPE: TS
SIZE: 5404 bytes
================================================================================
/**
 * Botpress Service Layer
 * Client-side service for Botpress AI operations
 * Maintains same interface as geminiService for easy migration
 */

import { logError } from './errorBoundaryService';

interface ApiResponse<T> {
  success: boolean;
  data?: T;
  message?: T; // For chat responses
  error?: string;
  code?: string;
  timestamp?: string;
}

interface ChatMessage {
  role: 'user' | 'model';
  parts: { text: string }[];
}

const API_BASE_URL = '/api';

// Input validation utilities (maintained from geminiService for consistency)
const validateBase64 = (base64Image: string): boolean => {
  if (typeof base64Image !== 'string') return false;
  const base64Regex = /^[A-Za-z0-9+/]*={0,2}$/;
  return base64Regex.test(base64Image) && base64Image.length > 0;
};

const validateMimeType = (mimeType: string): boolean => {
  const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'];
  return allowedTypes.includes(mimeType);
};

const sanitizeInput = (input: string): string => {
  if (typeof input !== 'string') return '';
  return input.replace(/[<>\"'&]/g, (match) => {
    const entities: Record<string, string> = {
      '<': '<',
      '>': '>',
      '"': '"',
      "'": '&#x27;',
      '&': '&',
    };
    // Type assertion: match is guaranteed to be a key of entities due to regex
    return entities[match as keyof typeof entities] || '';
  });
};

/**
 * Sends a chat message to Botpress via secure proxy
 * Maintains same interface as geminiService.sendChatMessage for compatibility
 *
 * @param message The user's message.
 * @param history The chat history.
 * @returns The model's text response.
 */
export const sendChatMessage = async (
  message: string,
  history: ChatMessage[] = []
): Promise<string> => {
  try {
    // Input validation (maintained from geminiService)
    if (!message || typeof message !== 'string') {
      throw new Error('Message is required');
    }

    if (message.length > 4000) {
      throw new Error('Message too long (max 4000 characters)');
    }

    // Validate history format
    if (!Array.isArray(history)) {
      history = [];
    }

    // Sanitize message
    const sanitizedMessage = sanitizeInput(message);
    const response = await fetch(`${API_BASE_URL}/ai/chat`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Requested-With': 'XMLHttpRequest',
      },
      body: JSON.stringify({
        message: sanitizedMessage,
        history: history.map((msg) => ({
          role: msg.role,
          parts: [{ text: sanitizeInput(msg.parts[0]?.text || '') }],
        })),
      }),
    });

    if (!response.ok) {
      const errorData: ApiResponse<null> = await response.json().catch(() => ({
        success: false,
        error: 'Server communication error',
      }));

      throw new Error(errorData.error || `HTTP ${response.status}`);
    }

    const result: ApiResponse<string> = await response.json();

    if (!result.success || !result.message) {
      throw new Error(result.error || 'Chat processing failed');
    }
    return result.message;
  } catch (error) {
    logError('Botpress chat error', {
      error: error as Error,
      component: 'botpressService',
    });

    // Provide user-friendly error messages (maintained from geminiService)
    if (error instanceof TypeError && error.message.includes('fetch')) {
      throw new Error(
        'Unable to connect to AI service. Please try again later.'
      );
    }

    throw error;
  }
};

/**
 * Health check for the Botpress service
 * Maintains same interface as geminiService.checkAiServiceHealth
 * @returns Promise<boolean> indicating service availability
 */
export const checkBotpressHealth = async (): Promise<boolean> => {
  try {
    const response = await fetch(`${API_BASE_URL}/health`, {
      method: 'GET',
      headers: {
        'X-Requested-With': 'XMLHttpRequest',
      },
    });

    if (!response.ok) {
      return false;
    }

    const data = await response.json();
    return data.status === 'healthy';
  } catch (error) {
    logError('Botpress health check failed', {
      error: error as Error,
      component: 'botpressService',
    });
    return false;
  }
};

/**
 * Image editing with Botpress (if supported)
 * This is a placeholder - Botpress may not support image editing like Gemini
 * For now, maintain the interface but throw a clear error
 *
 * @param base64Image The source image in base64 format
 * @param mimeType The mime type of the image
 * @param prompt The user's text instruction for editing
 * @returns Promise that rejects with clear error about unsupported feature
 */
export const editImageWithBotpress = async (
  base64Image: string,
  mimeType: string,
  prompt: string
): Promise<string> => {
  // Botpress doesn't typically support image editing like Gemini
  // This maintains interface compatibility but provides clear feedback
  throw new Error(
    'Image editing is not supported with Botpress. This feature was available with Gemini but is not part of the Botpress integration.'
  );
};

// Export validation utilities for testing (maintained from geminiService)
export const validationUtils = {
  validateBase64,
  validateMimeType,
  sanitizeInput,
};

// Default export for backward compatibility
export default {
  sendChatMessage,
  checkBotpressHealth,
  editImageWithBotpress,
  validationUtils,
};


[FILE_END: services\botpressService.ts]
################################################################################

================================================================================
FILE_BEGIN: services\errorBoundaryService.ts
TYPE: TS
SIZE: 1695 bytes
================================================================================
/**
 * Error Boundary Service
 * Centralized error logging and monitoring service
 * Follows architectural rules for error handling
 */

type ErrorSeverity = 'low' | 'medium' | 'high' | 'critical';

/**
 * Log an error to the monitoring service
 */
export const logError = (
  message: string,
  options?: {
    error?: Error;
    component?: string;
    severity?: ErrorSeverity;
    metadata?: Record<string, unknown>;
  }
): void => {
  const { error, component, severity = 'medium', metadata } = options || {};

  // In development, also log to console
  // eslint-disable-next-line no-console
  if (import.meta.env.DEV) {
    console.error(`[ErrorBoundary] ${severity.toUpperCase()}: ${message}`, {
      component,
      metadata,
      error,
    });
  }

  // In production, send to monitoring service (placeholder for future integration)
  // TODO: Integrate with Sentry, LogRocket, or similar
};

/**
 * Log a warning message
 */
export const logWarning = (
  message: string,
  options?: {
    component?: string;
    metadata?: Record<string, unknown>;
  }
): void => {
  const { component, metadata } = options || {};

  // eslint-disable-next-line no-console
  if (import.meta.env.DEV) {
    console.warn(`[Warning] ${message}`, { component, metadata });
  }
};

/**
 * Log an info message
 */
export const logInfo = (
  message: string,
  options?: {
    component?: string;
    metadata?: Record<string, unknown>;
  }
): void => {
  const { component, metadata } = options || {};

  // eslint-disable-next-line no-console
  if (import.meta.env.DEV) {
    console.log(`[Info] ${message}`, { component, metadata });
  }
};

export default {
  logError,
  logWarning,
  logInfo,
};


[FILE_END: services\errorBoundaryService.ts]
################################################################################

================================================================================
FILE_BEGIN: services\geminiService.ts
TYPE: TS
SIZE: 6414 bytes
================================================================================
/**
 * Secure Client-Side Service for AI Operations
 * All sensitive operations are now handled server-side via proxy
 * This eliminates API key exposure vulnerabilities
 */

import { logError } from './errorBoundaryService';

interface ApiResponse<T> {
  success: boolean;
  data?: T;
  message?: T; // For chat responses
  error?: string;
  code?: string;
  timestamp?: string;
}

interface ChatMessage {
  role: 'user' | 'model';
  parts: { text: string }[];
}

const API_BASE_URL = '/api';

// Input validation utilities
const validateBase64 = (base64Image: string): boolean => {
  if (typeof base64Image !== 'string') return false;
  const base64Regex = /^[A-Za-z0-9+/]*={0,2}$/;
  return base64Regex.test(base64Image) && base64Image.length > 0;
};

const validateMimeType = (mimeType: string): boolean => {
  const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'];
  return allowedTypes.includes(mimeType);
};

const sanitizeInput = (input: string): string => {
  if (typeof input !== 'string') return '';
  return input.replace(/[<>\\"'&]/g, (match) => {
    const entities: Record<string, string> = {
      '<': '<',
      '>': '>',
      '"': '"',
      "'": '&#x27;',
      '&': '&',
    };
    // Type assertion: match is guaranteed to be a key of entities due to regex
    return entities[match as keyof typeof entities] || '';
  });
};

/**
 * Edits an image based on a text prompt using secure server proxy
 *
 * @param base64Image The source image in base64 format (without the data prefix).
 * @param mimeType The mime type of the image.
 * @param prompt The user's text instruction for editing.
 * @returns A promise resolving to the base64 data URI of the generated image.
 */
export const editImageWithGemini = async (
  base64Image: string,
  mimeType: string,
  prompt: string
): Promise<string> => {
  try {
    // Input validation - CRITICAL for security
    if (!validateBase64(base64Image)) {
      throw new Error('Invalid image format');
    }

    if (!validateMimeType(mimeType)) {
      throw new Error('Unsupported image format');
    }

    if (!prompt || typeof prompt !== 'string') {
      throw new Error('Prompt is required');
    }

    if (prompt.length > 1000) {
      throw new Error('Prompt too long (max 1000 characters)');
    }

    // Sanitize inputs
    const sanitizedPrompt = sanitizeInput(prompt);
    const response = await fetch(`${API_BASE_URL}/ai/edit-image`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Requested-With': 'XMLHttpRequest',
      },
      body: JSON.stringify({
        base64Image,
        mimeType,
        prompt: sanitizedPrompt,
      }),
    });

    if (!response.ok) {
      const errorData: ApiResponse<null> = await response.json().catch(() => ({
        success: false,
        error: 'Server communication error',
      }));

      throw new Error(errorData.error || `HTTP ${response.status}`);
    }

    const result: ApiResponse<string> = await response.json();

    if (!result.success || !result.data) {
      throw new Error(result.error || 'Image processing failed');
    }
    return result.data;
  } catch (error) {
    logError('Image edit error', {
      error: error as Error,
      component: 'geminiService',
    });

    // Provide user-friendly error messages
    if (error instanceof TypeError && error.message.includes('fetch')) {
      throw new Error(
        'Unable to connect to AI service. Please try again later.'
      );
    }

    throw error;
  }
};

/**
 * Sends a chat message to Gemini via secure proxy
 *
 * @param message The user's message.
 * @param history The chat history.
 * @returns The model's text response.
 */
export const sendChatMessage = async (
  message: string,
  history: ChatMessage[] = []
): Promise<string> => {
  try {
    // Input validation
    if (!message || typeof message !== 'string') {
      throw new Error('Message is required');
    }

    if (message.length > 4000) {
      throw new Error('Message too long (max 4000 characters)');
    }

    // Validate history format
    if (!Array.isArray(history)) {
      history = [];
    }

    // Sanitize message
    const sanitizedMessage = sanitizeInput(message);
    const response = await fetch(`${API_BASE_URL}/ai/chat`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Requested-With': 'XMLHttpRequest',
      },
      body: JSON.stringify({
        message: sanitizedMessage,
        history: history.map((msg) => ({
          role: msg.role,
          parts: [{ text: sanitizeInput(msg.parts[0]?.text || '') }],
        })),
      }),
    });

    if (!response.ok) {
      const errorData: ApiResponse<null> = await response.json().catch(() => ({
        success: false,
        error: 'Server communication error',
      }));

      throw new Error(errorData.error || `HTTP ${response.status}`);
    }

    const result: ApiResponse<string> = await response.json();

    if (!result.success || !result.message) {
      throw new Error(result.error || 'Chat processing failed');
    }
    return result.message;
  } catch (error) {
    logError('Chat error', {
      error: error as Error,
      component: 'geminiService',
    });

    // Provide user-friendly error messages
    if (error instanceof TypeError && error.message.includes('fetch')) {
      throw new Error(
        'Unable to connect to AI service. Please try again later.'
      );
    }

    throw error;
  }
};

/**
 * Health check for the AI service
 * @returns Promise<boolean> indicating service availability
 */
export const checkAiServiceHealth = async (): Promise<boolean> => {
  try {
    const response = await fetch(`${API_BASE_URL}/health`, {
      method: 'GET',
      headers: {
        'X-Requested-With': 'XMLHttpRequest',
      },
    });

    if (!response.ok) {
      return false;
    }

    const data = await response.json();
    return data.status === 'healthy';
  } catch (error) {
    logError('Health check failed', {
      error: error as Error,
      component: 'geminiService',
    });
    return false;
  }
};

// Export validation utilities for testing
export const validationUtils = {
  validateBase64,
  validateMimeType,
  sanitizeInput,
};

// Default export for backward compatibility
export default {
  sendChatMessage,
  editImageWithGemini,
  checkAiServiceHealth,
  validationUtils,
};


[FILE_END: services\geminiService.ts]
################################################################################

================================================================================
FILE_BEGIN: src\services\geminiService.test.ts
TYPE: TS
SIZE: 7060 bytes
================================================================================
/**
 * Unit tests for geminiService.ts
 * Tests validation utilities and service functions
 */

import {
  editImageWithGemini,
  sendChatMessage,
  checkAiServiceHealth,
  validationUtils,
} from '../../services/geminiService';

describe('geminiService Validation Utilities', () => {
  describe('validateBase64', () => {
    it('should return true for valid base64 string', () => {
      expect(validationUtils.validateBase64('SGVsbG8gV29ybGQ=')).toBe(true);
      expect(validationUtils.validateBase64('dGVzdDEyMzQ=')).toBe(true);
      expect(validationUtils.validateBase64('YWJjZGVmZ2hpamtsbW5vcA==')).toBe(
        true
      );
    });

    it('should return false for invalid base64 string', () => {
      expect(validationUtils.validateBase64('')).toBe(false);
      expect(validationUtils.validateBase64('!!!')).toBe(false);
      expect(validationUtils.validateBase64(null as unknown as string)).toBe(
        false
      );
      expect(
        validationUtils.validateBase64(undefined as unknown as string)
      ).toBe(false);
    });

    it('should return false for non-string input', () => {
      expect(validationUtils.validateBase64(123 as unknown as string)).toBe(
        false
      );
      expect(validationUtils.validateBase64({} as unknown as string)).toBe(
        false
      );
    });
  });

  describe('validateMimeType', () => {
    it('should return true for allowed mime types', () => {
      expect(validationUtils.validateMimeType('image/jpeg')).toBe(true);
      expect(validationUtils.validateMimeType('image/jpg')).toBe(true);
      expect(validationUtils.validateMimeType('image/png')).toBe(true);
      expect(validationUtils.validateMimeType('image/webp')).toBe(true);
    });

    it('should return false for disallowed mime types', () => {
      expect(validationUtils.validateMimeType('image/gif')).toBe(false);
      expect(validationUtils.validateMimeType('image/bmp')).toBe(false);
      expect(validationUtils.validateMimeType('application/pdf')).toBe(false);
      expect(validationUtils.validateMimeType('')).toBe(false);
    });
  });

  describe('sanitizeInput', () => {
    it('should sanitize HTML special characters', () => {
      expect(
        validationUtils.sanitizeInput('<script>alert("xss")</script>')
      ).toBe('<script>alert("xss")</script>');
      expect(validationUtils.sanitizeInput("It's a test")).toBe(
        'It&#x27;s a test'
      );
      expect(validationUtils.sanitizeInput('AT&T')).toBe('AT&T');
      expect(validationUtils.sanitizeInput('<div>Content</div>')).toBe(
        '<div>Content</div>'
      );
    });

    it('should return empty string for non-string input', () => {
      expect(validationUtils.sanitizeInput(null as unknown as string)).toBe('');
      expect(
        validationUtils.sanitizeInput(undefined as unknown as string)
      ).toBe('');
      expect(validationUtils.sanitizeInput(123 as unknown as string)).toBe('');
    });

    it('should pass through safe strings unchanged', () => {
      expect(validationUtils.sanitizeInput('Hello World')).toBe('Hello World');
      expect(validationUtils.sanitizeInput('Property at 123 Main St')).toBe(
        'Property at 123 Main St'
      );
    });
  });
});

describe('geminiService API Functions', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe('editImageWithGemini', () => {
    it('should throw error for invalid base64 image', async () => {
      await expect(
        editImageWithGemini('!!!invalid!!!', 'image/jpeg', 'Make it brighter')
      ).rejects.toThrow('Invalid image format');
    });

    it('should throw error for unsupported mime type', async () => {
      await expect(
        editImageWithGemini('SGVsbG8gV29ybGQ=', 'image/gif', 'Make it brighter')
      ).rejects.toThrow('Unsupported image format');
    });

    it('should throw error for empty prompt', async () => {
      await expect(
        editImageWithGemini('SGVsbG8gV29ybGQ=', 'image/jpeg', '')
      ).rejects.toThrow('Prompt is required');
    });

    it('should throw error for prompt exceeding max length', async () => {
      const longPrompt = 'a'.repeat(1001);
      await expect(
        editImageWithGemini('SGVsbG8gV29ybGQ=', 'image/jpeg', longPrompt)
      ).rejects.toThrow('Prompt too long');
    });

    it('should throw error for non-string prompt', async () => {
      await expect(
        editImageWithGemini(
          'SGVsbG8gV29ybGQ=',
          'image/jpeg',
          null as unknown as string
        )
      ).rejects.toThrow('Prompt is required');
    });
  });

  describe('sendChatMessage', () => {
    it('should throw error for empty message', async () => {
      await expect(sendChatMessage('')).rejects.toThrow('Message is required');
    });

    it('should throw error for non-string message', async () => {
      await expect(sendChatMessage(null as unknown as string)).rejects.toThrow(
        'Message is required'
      );
    });

    it('should throw error for message exceeding max length', async () => {
      const longMessage = 'a'.repeat(4001);
      await expect(sendChatMessage(longMessage)).rejects.toThrow(
        'Message too long'
      );
    });

    it('should handle empty history array gracefully', async () => {
      globalThis.fetch = vi.fn().mockResolvedValue({
        ok: true,
        status: 200,
        json: () => Promise.resolve({ success: true, message: 'Hello back!' }),
      });
      const result = await sendChatMessage('Hello', []);
      expect(Array.isArray(result)).toBe(false);
      expect(result).toBe('Hello back!');
    });
  });

  describe('checkAiServiceHealth', () => {
    it('should return false on fetch failure', async () => {
      globalThis.fetch = vi.fn().mockRejectedValue(new Error('Network error'));
      const result = await checkAiServiceHealth();
      expect(result).toBe(false);
    });

    it('should return false for non-ok response', async () => {
      globalThis.fetch = vi.fn().mockResolvedValue({
        ok: false,
        status: 500,
        json: () => Promise.resolve({}),
      });
      const result = await checkAiServiceHealth();
      expect(result).toBe(false);
    });

    it('should return false when status is not healthy', async () => {
      globalThis.fetch = vi.fn().mockResolvedValue({
        ok: true,
        status: 200,
        json: () => Promise.resolve({ status: 'unhealthy' }),
      });
      const result = await checkAiServiceHealth();
      expect(result).toBe(false);
    });
  });
});

describe('validationUtils export', () => {
  it('should export all validation functions', () => {
    expect(validationUtils).toHaveProperty('validateBase64');
    expect(validationUtils).toHaveProperty('validateMimeType');
    expect(validationUtils).toHaveProperty('sanitizeInput');
    expect(typeof validationUtils.validateBase64).toBe('function');
    expect(typeof validationUtils.validateMimeType).toBe('function');
    expect(typeof validationUtils.sanitizeInput).toBe('function');
  });
});


[FILE_END: src\services\geminiService.test.ts]
################################################################################

================================================================================
FILE_BEGIN: src\services\geminiService.ts
TYPE: TS
SIZE: 6648 bytes
================================================================================
import {
  GoogleGenerativeAI,
  ChatSession as GoogleChatSession,
} from '@google/generative-ai';

// Initialize Google Generative AI with API key
const getEnvVar = (key: string): string => {
  // eslint-disable-next-line dot-notation
  const val = import.meta.env?.[key as string];
  if (val) return val;
  // eslint-disable-next-line dot-notation
  return process.env?.[key as string] || '';
};

const apiKey = getEnvVar('VITE_GEMINI_API_KEY');

if (!apiKey) {
  // eslint-disable-next-line no-console
  console.warn(
    'Gemini API key not found. Set VITE_GEMINI_API_KEY in your environment variables.'
  );
}

const genAI = new GoogleGenerativeAI(apiKey || '');

interface Message {
  role: 'user' | 'model';
  text: string;
}

class GeminiService {
  private chatSession: GoogleChatSession | null = null;
  private isInitialized = false;

  /**
   * Initialize the Gemini service with the specified model
   */
  initialize(): Promise<void> {
    if (this.isInitialized) return Promise.resolve();

    try {
      // Use the cost-effective gemini-2.5-flash model
      const model = genAI.getGenerativeModel({
        model: 'gemini-2.5-flash',
        systemInstruction: {
          role: 'system',
          parts: [
            {
              text: `You are Patriot, a virtual concierge for Properties 4 Creation (P4C).
            Help veterans with housing/vouchers and their families find suitable homes.
            Your tone should be warm, professional, and supportive.
            Focus on providing helpful information about housing options,
            veteran resources, and the application process.
            You are knowledgeable about East Texas housing market and veteran benefits.`,
            },
          ],
        },
      });

      // Configure generation parameters for cost efficiency
      const generationConfig = {
        temperature: 0.7,
        topK: 1,
        topP: 1,
        maxOutputTokens: 250, // Limit tokens to save quota
        stopSequences: ['\n\n'],
      };

      this.chatSession = model.startChat({
        generationConfig,
        history: [],
      }) as GoogleChatSession;

      this.isInitialized = true;
      return Promise.resolve();
    } catch (error) {
      // eslint-disable-next-line no-console
      console.error('Failed to initialize Gemini service:', error);
      return Promise.reject(new Error('Gemini service initialization failed'));
    }
  }

  /**
   * Send a chat message to the Gemini model
   * @param message - The user's message
   * @returns Promise with the model's response
   */
  async sendChatMessage(message: string): Promise<string> {
    if (!this.isInitialized) {
      await this.initialize();
    }

    try {
      if (!this.chatSession) {
        throw new Error('Chat session not initialized');
      }

      const result = await this.chatSession.sendMessage(message);
      const response = result.response;
      const text = response.text();

      return text;
    } catch (error) {
      // eslint-disable-next-line no-console
      console.error('Error sending chat message:', error);

      // Return a helpful fallback message
      if (error instanceof Error) {
        const errorMessage = error.message;
        if (errorMessage.includes('quota')) {
          return "I'm sorry, but I've reached my usage limit for today. Please try again later, or contact our team directly for assistance with your housing needs.";
        }
        if (errorMessage.includes('API key')) {
          return "I'm currently unable to access the AI service. Please try refreshing the page or contact our support team for assistance.";
        }
      }

      return "I apologize, but I'm experiencing technical difficulties. Please try your question again in a moment, or contact our team directly for immediate assistance with your housing needs.";
    }
  }

  /**
   * Edit an image with Gemini (placeholder for future implementation)
   * @param _imageData - Base64 encoded image data (reserved for future use)
   * @param _prompt - The editing prompt (reserved for future use)
   * @returns Promise with the edited image or error message
   */
  /* eslint-disable no-unused-vars */
  async editImageWithGemini(
    _imageData: string,
    _prompt: string
  ): Promise<string> {
    /* eslint-enable no-unused-vars */
    // Parameters are reserved for future implementation
    // TODO: Implement image editing when gemini-pro-vision model is available
    if (import.meta.env?.DEV) {
      // eslint-disable-next-line no-console
      console.log(
        'Image editing requested with params (reserved for future use)'
      );
    }

    try {
      if (!this.isInitialized) {
        await this.initialize();
      }

      return `I'm currently unable to edit images directly. However, I can help you with:

      1. **Finding suitable properties** based on your preferences
      2. **Understanding veteran housing benefits** and how to apply for them
      3. **Guidance on the application process** for our properties
      4. **Information about available housing programs** in East Texas

      If you have a specific property image you'd like to discuss or need help with any housing-related questions, please let me know!`;
    } catch (error) {
      // eslint-disable-next-line no-console
      console.error('Error editing image:', error);
      return "I'm sorry, but I'm currently unable to process image editing requests. Please try again later or contact our team for assistance.";
    }
  }

  /**
   * Get the current chat history
   */
  async getChatHistory(): Promise<Message[]> {
    if (!this.chatSession) {
      return [];
    }

    try {
      const history = await this.chatSession.getHistory();
      return history.map(
        (entry: { role: string; parts: Array<{ text?: string }> }) => ({
          role: entry.role === 'user' ? 'user' : 'model',
          text: entry.parts[0]?.text || '',
        })
      );
    } catch (error) {
      // eslint-disable-next-line no-console
      console.error('Error getting chat history:', error);
      return [];
    }
  }

  /**
   * Clear the chat history
   */
  async clearChatHistory(): Promise<void> {
    if (this.chatSession) {
      try {
        // Restart the chat session to clear history
        await this.initialize();
      } catch (error) {
        // eslint-disable-next-line no-console
        console.error('Error clearing chat history:', error);
      }
    }
  }
}

// Export singleton instance
export const geminiService = new GeminiService();

// Export types for use in components
export type { Message };
export default geminiService;


[FILE_END: src\services\geminiService.ts]
################################################################################

================================================================================
FILE_BEGIN: src\test\setup.ts
TYPE: TS
SIZE: 909 bytes
================================================================================
/**
 * Global test setup file for Vitest
 * Configures the test environment for P4C React components
 */

import { vi } from 'vitest';

// Mock window.matchMedia for components that use it
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: vi.fn().mockImplementation((query) => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: vi.fn(),
    removeListener: vi.fn(),
    addEventListener: vi.fn(),
    removeEventListener: vi.fn(),
    dispatchEvent: vi.fn(),
  })),
});

// Mock ResizeObserver for components using it
global.ResizeObserver = vi.fn().mockImplementation(() => ({
  observe: vi.fn(),
  unobserve: vi.fn(),
  disconnect: vi.fn(),
}));

// Suppress console.error in tests to reduce noise
// Only uncomment if debugging: vi.spyOn(console, 'error').mockImplementation(() => {});

// Set default test timeout
vi.setConfig({
  testTimeout: 10000,
});


[FILE_END: src\test\setup.ts]
################################################################################

================================================================================
FILE_BEGIN: types\contentBalance.ts
TYPE: TS
SIZE: 943 bytes
================================================================================
/**
 * P4C Content Balance Auditor Types
 * Type definitions for the Content Balance Auditor system
 */

export interface AuditResult {
  veteranWeight: number;
  familyWeight: number;
  ratio: string;
  veteranPerc: number;
  familyPerc: number;
  recommendations: string[];
}

export interface RouteConfig {
  path: string;
  veteranWeight?: number;
  familyWeight?: number;
}

export interface ContentAuditorConfig {
  veteranKeywords: string[];
  familyKeywords: string[];
  routeWeights: RouteConfig[];
}

export interface ContentBalanceWidgetProps {
  auditResult: AuditResult;
  onRefresh: () => void;
}

export interface ContentBalanceChartProps {
  veteranPerc: number;
  familyPerc: number;
}

export type ContentType = 'veteran' | 'family' | 'neutral';

export interface StoryContent {
  id: number;
  name: string;
  location: string;
  quote: string;
  videoLabel: string;
  type: ContentType;
  contentTypeDescription: string;
}


[FILE_END: types\contentBalance.ts]
################################################################################

================================================================================
FILE_BEGIN: types.ts
TYPE: TS
SIZE: 1017 bytes
================================================================================
export interface Property {
  id: string;
  title: string;
  address: string;
  price: number;
  beds: number;
  baths: number;
  sqft: number;
  imageUrl: string;
  badges: string[];
  description: string;
}

export interface ExtendedProperty extends Property {
  amenities: string[];
  accessibilityFeatures: string[];
  schoolDistrict: string;
  neighborhood: string;
  availabilityDate: string;
  coordinates: { lat: number; lng: number };
}

export interface TransformationData {
  beforeImage: string;
  afterImage: string;
  label: string;
}

export interface StatMetric {
  id: string;
  label: string;
  value: string;
  icon: 'users' | 'home' | 'hammer' | 'dollar' | 'heart';
  description?: string;
  trend?: 'up' | 'down' | 'neutral';
  trendValue?: string;
}

export interface RenovationStandard {
  id: string;
  category: string;
  standardLandlord: string;
  p4cStandard: string;
  benefit: string;
}

export interface FinancialBreakdown {
  category: string;
  percentage: number;
  color: string;
}


[FILE_END: types.ts]
################################################################################

================================================================================
FILE_BEGIN: utils\contentBalanceAuditor.test.ts
TYPE: TS
SIZE: 6297 bytes
================================================================================
/**
 * Content Balance Auditor Tests
 * Unit tests for the content balance auditor utility
 */

import { describe, expect, test, vi } from 'vitest';
import {
  auditContentBalance,
  analyzePropertyContent,
  auditStoryBalance,
  createBalancedStories,
} from './contentBalanceAuditor';
import type { ExtendedProperty } from '../types';
import type { StoryContent } from '../types/contentBalance';

// Mock error boundary service
vi.mock('../services/errorBoundaryService', () => ({
  logError: vi.fn(),
}));

// Test Data
describe('Content Balance Auditor', () => {
  // Mock properties for testing
  const mockProperties: ExtendedProperty[] = [
    {
      id: '1',
      title: 'Veteran-Focused Property',
      address: '123 Main St',
      price: 1000,
      beds: 2,
      baths: 1,
      sqft: 1000,
      imageUrl: 'test.jpg',
      badges: ['VASH Approved'],
      description: 'Property for veterans with VASH benefits near VA clinic',
      amenities: [],
      accessibilityFeatures: [],
      schoolDistrict: 'Test ISD',
      neighborhood: 'Test',
      availabilityDate: 'Available Now',
      coordinates: { lat: 0, lng: 0 },
    },
    {
      id: '2',
      title: 'Family-Focused Property',
      address: '456 Oak St',
      price: 1200,
      beds: 3,
      baths: 2,
      sqft: 1500,
      imageUrl: 'test.jpg',
      badges: ['Family Size'],
      description: 'Spacious home near elementary school perfect for families',
      amenities: [],
      accessibilityFeatures: [],
      schoolDistrict: 'Test ISD',
      neighborhood: 'Test',
      availabilityDate: 'Available Now',
      coordinates: { lat: 0, lng: 0 },
    },
  ];

  // Mock routes for testing
  const mockRoutes = [
    { path: '/veterans' },
    { path: '/family-resources' },
    { path: '/apply' },
  ];

  test('should analyze property content correctly', () => {
    const veteranResult = analyzePropertyContent(mockProperties[0]!);
    const familyResult = analyzePropertyContent(mockProperties[1]!);

    expect(veteranResult).toBe('veteran');
    expect(familyResult).toBe('family');
  });

  test('should audit content balance with correct scoring', () => {
    const result = auditContentBalance(mockRoutes, mockProperties);

    expect(result.veteranWeight).toBeGreaterThan(0);
    expect(result.familyWeight).toBeGreaterThan(0);
    expect(result.veteranPerc + result.familyPerc).toBe(100);
    expect(result.ratio).toMatch(/\d+% Veteran \/ \d+% Family/);
  });

  test('should handle empty inputs gracefully', () => {
    const result = auditContentBalance([], []);

    expect(result.veteranWeight).toBe(0);
    expect(result.familyWeight).toBe(0);
    expect(result.veteranPerc).toBe(0);
    expect(result.familyPerc).toBe(0);
  });

  test('should generate recommendations for imbalanced content', () => {
    // Create heavily veteran-biased content
    const veteranProperties = Array(10).fill(mockProperties[0]);
    const result = auditContentBalance(mockRoutes, veteranProperties);

    if (result.veteranPerc > 60) {
      expect(result.recommendations).toContain('High Veteran Tilt detected');
    }
  });

  test('should audit story balance correctly', () => {
    const mockStories: StoryContent[] = [
      {
        id: 1,
        name: 'John Veteran',
        location: 'Tyler, TX',
        quote: 'Great experience as a veteran',
        videoLabel: 'Veteran story',
        type: 'veteran',
        contentTypeDescription: 'Veteran Success Story',
      },
      {
        id: 2,
        name: 'Jane Family',
        location: 'Longview, TX',
        quote: 'Perfect for our family',
        videoLabel: 'Family story',
        type: 'family',
        contentTypeDescription: 'Family Success Story',
      },
    ];

    const result = auditStoryBalance(mockStories);

    expect(result.veteranWeight).toBe(10);
    expect(result.familyWeight).toBe(10);
    expect(result.ratio).toBe('50% Veteran / 50% Family');
  });

  test('should create balanced stories with proper typing', () => {
    const mockStories: StoryContent[] = [
      {
        id: 1,
        name: 'Test Veteran',
        location: 'Tyler, TX',
        quote: 'Military service helped me get this home',
        videoLabel: 'Test veteran story',
        type: 'veteran',
        contentTypeDescription: 'Veteran Success Story',
      },
      {
        id: 2,
        name: 'Test Family',
        location: 'Longview, TX',
        quote: 'Our children love the school nearby',
        videoLabel: 'Test family story',
        type: 'family',
        contentTypeDescription: 'Family Success Story',
      },
    ];

    const result = createBalancedStories(mockStories);

    expect(result.length).toBe(2);
    expect(result[0]?.type).toBeDefined();
    expect(result[0]?.contentTypeDescription).toBeDefined();
    expect(result[1]?.type).toBeDefined();
    expect(result[1]?.contentTypeDescription).toBeDefined();
  });

  test('should handle errors gracefully', () => {
    // This should not throw, but return a safe default
    const result = auditContentBalance([], []);

    expect(result).toBeDefined();
    expect(result.recommendations).toBeInstanceOf(Array);
  });

  test('should use default configuration when none provided', () => {
    const result = auditContentBalance([], []);

    // Should complete without errors using default config
    expect(result).toBeDefined();
  });
});

// Integration test
describe('Content Balance Auditor Integration', () => {
  test('should work with real-world property data structure', () => {
    const realProperty: ExtendedProperty = {
      id: 'test',
      title: 'Real Property',
      address: '123 Test St',
      price: 1000,
      beds: 2,
      baths: 1,
      sqft: 1000,
      imageUrl: 'test.jpg',
      badges: ['Section 8 Approved'],
      description: 'Real property description with school district mentions',
      amenities: ['Test amenity'],
      accessibilityFeatures: [],
      schoolDistrict: 'Test ISD',
      neighborhood: 'Test Neighborhood',
      availabilityDate: 'Available Now',
      coordinates: { lat: 32.3513, lng: -95.3011 },
    };

    // Should not throw with real property structure
    const result = analyzePropertyContent(realProperty);
    expect(['veteran', 'family', 'neutral']).toContain(result);
  });
});


[FILE_END: utils\contentBalanceAuditor.test.ts]
################################################################################

================================================================================
FILE_BEGIN: utils\contentBalanceAuditor.ts
TYPE: TS
SIZE: 7690 bytes
================================================================================
/**
 * P4C Content Balance Auditor
 *  * Version: 1.0.0
 * Purpose: Analyzes the semantic weight of content to ensure a 50/50 balance
 * between Veteran and Family outreach.
 */

import type {
  AuditResult,
  RouteConfig,
  ContentAuditorConfig,
  ContentType,
  StoryContent,
} from '../types/contentBalance';
import type { ExtendedProperty } from '../types';

/**
 * Default configuration for the content auditor
 */
export const DEFAULT_CONFIG: ContentAuditorConfig = {
  veteranKeywords: [
    'vash',
    'veteran',
    'military',
    'va clinic',
    'rehousing',
    'rapid rehousing',
    'service',
    'armed forces',
  ],
  familyKeywords: [
    'school',
    'elementary',
    'park',
    'voucher',
    'family',
    'children',
    'district',
    'child',
    'kids',
  ],
  routeWeights: [
    { path: '/veterans', veteranWeight: 10 },
    { path: '/veteran-services', veteranWeight: 10 },
    { path: '/stories', veteranWeight: 8 },
    { path: '/homeowner-solutions', familyWeight: 10 },
    { path: '/apply', familyWeight: 8 },
    { path: '/equal-housing', familyWeight: 7 },
    { path: '/family-resources', familyWeight: 10 },
  ],
};

/**
 * Analyzes property content for veteran/family keywords
 * @param property - Property data to analyze
 * @param config - Auditor configuration
 * @returns Content type classification
 */
export const analyzePropertyContent = (
  property: ExtendedProperty,
  config: ContentAuditorConfig = DEFAULT_CONFIG
): ContentType => {
  const text = (
    property.description +
    property.badges.join(' ') +
    (property.amenities?.join(' ') || '')
  ).toLowerCase();

  // Check for veteran markers
  const veteranMatches = config.veteranKeywords.filter((keyword) =>
    text.includes(keyword.toLowerCase())
  ).length;

  // Check for family markers
  const familyMatches = config.familyKeywords.filter((keyword) =>
    text.includes(keyword.toLowerCase())
  ).length;

  if (veteranMatches > familyMatches) return 'veteran';
  if (familyMatches > veteranMatches) return 'family';
  return 'neutral';
};

/**
 * Analyzes story content for veteran/family focus
 * @param story - Story content to analyze
 * @returns Content type classification
 */
export const analyzeStoryContent = (story: StoryContent): ContentType => {
  const text = `${story.quote} ${story.contentTypeDescription}`.toLowerCase();

  const veteranKeywords = [
    'veteran',
    'military',
    'service',
    'armed forces',
    'va',
    'vash',
  ];
  const familyKeywords = [
    'family',
    'children',
    'child',
    'kids',
    'school',
    'district',
  ];

  const veteranMatches = veteranKeywords.filter((keyword) =>
    text.includes(keyword.toLowerCase())
  ).length;

  const familyMatches = familyKeywords.filter((keyword) =>
    text.includes(keyword.toLowerCase())
  ).length;

  if (veteranMatches > familyMatches) return 'veteran';
  if (familyMatches > veteranMatches) return 'family';
  return 'neutral';
};

/**
 * Main audit function that analyzes routes and properties
 * @param routes - Array of route configurations
 * @param properties - Array of property data
 * @param config - Auditor configuration
 * @returns Comprehensive audit result
 */
export const auditContentBalance = (
  routes: RouteConfig[],
  properties: ExtendedProperty[],
  config: ContentAuditorConfig = DEFAULT_CONFIG
): AuditResult => {
  let vScore = 0;
  let fScore = 0;
  const tips: string[] = [];

  try {
    // 1. Analyze Page Routing (Nav Structure)
    routes.forEach((route) => {
      if (route.veteranWeight) vScore += route.veteranWeight;
      if (route.familyWeight) fScore += route.familyWeight;
    });

    // 2. Analyze Property Data (Semantic Keywords)
    properties.forEach((property) => {
      const contentType = analyzePropertyContent(property, config);

      if (contentType === 'veteran') {
        vScore += 5;
      } else if (contentType === 'family') {
        fScore += 5;
      }
    });

    const total = vScore + fScore;
    const vPerc = total > 0 ? Math.round((vScore / total) * 100) : 0;
    const fPerc = total > 0 ? Math.round((fScore / total) * 100) : 0;

    // 3. Generate Architect Recommendations
    const gap = Math.abs(vPerc - fPerc);

    if (vPerc > 60) {
      tips.push(
        "High Veteran Tilt detected. Add 'Family Success Stories' to /stories to balance military testimonials."
      );
      tips.push(
        'Update PropertyCard badges to highlight proximity to Tyler/Longview schools more prominently.'
      );
    }

    if (fPerc > 60) {
      tips.push(
        'High Family Tilt detected. Consider adding veteran-specific content to balance the representation.'
      );
      tips.push(
        'Highlight VA benefits and veteran programs in property descriptions.'
      );
    }

    if (gap > 20) {
      tips.push(
        `Significant imbalance detected (${gap}% gap). Consider creating dedicated content sections for the underrepresented group.`
      );
    }

    if (gap < 10) {
      tips.push(
        'Excellent balance achieved! Maintain this ratio for optimal audience representation.'
      );
    }

    return {
      veteranWeight: vScore,
      familyWeight: fScore,
      ratio: `${vPerc}% Veteran / ${fPerc}% Family`,
      veteranPerc: vPerc,
      familyPerc: fPerc,
      recommendations: tips,
    };
  } catch (error) {
    // Log error to error boundary service
    import('../services/errorBoundaryService').then(({ logError }) => {
      logError('Content Balance Auditor failed', {
        error:
          error instanceof Error
            ? error
            : new Error('Unknown error in Content Balance Auditor'),
        component: 'contentBalanceAuditor',
        severity: 'high',
      });
    });

    return {
      veteranWeight: 0,
      familyWeight: 0,
      ratio: '0% Veteran / 0% Family',
      veteranPerc: 0,
      familyPerc: 0,
      recommendations: [
        'Auditor encountered an error. Please check configuration.',
      ],
    };
  }
};

/**
 * Analyzes story content balance
 * @param stories - Array of story content
 * @returns Audit result for stories
 */
export const auditStoryBalance = (stories: StoryContent[]): AuditResult => {
  let vScore = 0;
  let fScore = 0;
  const tips: string[] = [];

  stories.forEach((story) => {
    const contentType = analyzeStoryContent(story);

    if (contentType === 'veteran') {
      vScore += 10;
    } else if (contentType === 'family') {
      fScore += 10;
    }
  });

  const total = vScore + fScore;
  const vPerc = total > 0 ? Math.round((vScore / total) * 100) : 0;
  const fPerc = total > 0 ? Math.round((fScore / total) * 100) : 0;

  // Generate recommendations for stories
  const gap = Math.abs(vPerc - fPerc);

  if (gap > 15) {
    tips.push(
      `Story imbalance detected (${gap}% gap). Add more ${vPerc > fPerc ? 'family' : 'veteran'} stories to balance representation.`
    );
  }

  return {
    veteranWeight: vScore,
    familyWeight: fScore,
    ratio: `${vPerc}% Veteran / ${fPerc}% Family`,
    veteranPerc: vPerc,
    familyPerc: fPerc,
    recommendations: tips,
  };
};

/**
 * Creates balanced story content array
 * @param stories - Original stories
 * @returns Balanced stories with type classification
 */
export const createBalancedStories = (
  stories: StoryContent[]
): StoryContent[] =>
  stories.map((story) => {
    const contentType = analyzeStoryContent(story);

    return {
      ...story,
      type: contentType,
      contentTypeDescription:
        contentType === 'veteran'
          ? 'Veteran Success Story'
          : contentType === 'family'
            ? 'Family Success Story'
            : 'General Story',
    };
  });


[FILE_END: utils\contentBalanceAuditor.ts]
################################################################################

================================================================================
FILE_BEGIN: utils\formatters.ts
TYPE: TS
SIZE: 2167 bytes
================================================================================
/**
 * Utility functions for formatting data throughout the application
 */

/**
 * Formats a number as USD currency
 * @param amount - The amount to format
 * @param options - Intl.NumberFormat options
 * @returns Formatted currency string
 */
export const formatCurrency = (
  amount: number,
  options?: Intl.NumberFormatOptions
): string => {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    minimumFractionDigits: 0,
    maximumFractionDigits: 0,
    ...options,
  }).format(amount);
};

/**
 * Formats a number with thousands separators
 * @param num - The number to format
 * @returns Formatted number string
 */
export const formatNumber = (num: number): string => {
  return new Intl.NumberFormat('en-US').format(num);
};

/**
 * Formats a date string to a human-readable format
 * @param dateString - ISO date string
 * @param options - Intl.DateTimeFormat options
 * @returns Formatted date string
 */
export const formatDate = (
  dateString: string,
  options?: Intl.DateTimeFormatOptions
): string => {
  const date = new Date(dateString);
  return new Intl.DateTimeFormat('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    ...options,
  }).format(date);
};

/**
 * Truncates text to a specified length with ellipsis
 * @param text - The text to truncate
 * @param maxLength - Maximum length before truncation
 * @returns Truncated text with ellipsis if needed
 */
export const truncateText = (text: string, maxLength: number): string => {
  if (text.length <= maxLength) return text;
  return `${text.slice(0, maxLength)}...`;
};

/**
 * Generates initials from a name
 * @param name - Full name
 * @returns Initials string
 */
export const getInitials = (name: string): string => {
  return name
    .split(' ')
    .map((part) => part[0])
    .join('')
    .toUpperCase()
    .slice(0, 2);
};

/**
 * Slugifies a string for URLs
 * @param text - The text to slugify
 * @returns URL-safe slug string
 */
export const slugify = (text: string): string => {
  return text
    .toLowerCase()
    .replace(/[^\w\s-]/g, '')
    .replace(/\s+/g, '-')
    .replace(/--+/g, '-')
    .trim();
};


[FILE_END: utils\formatters.ts]
################################################################################

================================================================================
FILE_BEGIN: utils\imageOptimization.ts
TYPE: TS
SIZE: 5344 bytes
================================================================================
/**
 * Image Optimization Utilities
 * Supports WebP/AVIF format detection and conversion
 */

export interface ImageFormat {
  webp: boolean;
  avif: boolean;
  original: string;
}

export interface OptimizedImageConfig {
  quality: number;
  progressive: boolean;
  lossy: boolean;
  effort: number;
}

export interface ResponsiveImageConfig {
  breakpoints: number[];
  formats: ('webp' | 'avif' | 'jpeg' | 'png')[];
  quality: number;
  sizes: string[];
}

// Check browser support for modern image formats
export const detectImageFormatSupport = (): ImageFormat => {
  const webp = checkWebPSupport();
  const avif = checkAVIFSupport();

  return {
    webp,
    avif,
    original: 'jpeg',
  };
};

// Check WebP support
const checkWebPSupport = (): boolean => {
  const canvas = document.createElement('canvas');
  canvas.width = 1;
  canvas.height = 1;
  return canvas.toDataURL('image/webp').indexOf('data:image/webp') === 0;
};

// Check AVIF support
const checkAVIFSupport = (): boolean => {
  const canvas = document.createElement('canvas');
  canvas.width = 1;
  canvas.height = 1;
  return canvas.toDataURL('image/avif').indexOf('data:image/avif') === 0;
};

// Get optimal image format based on browser support
export const getOptimalImageFormat = (
  formats: ImageFormat
): 'avif' | 'webp' | 'jpeg' => {
  if (formats.avif) return 'avif';
  if (formats.webp) return 'webp';
  return 'jpeg';
};

// Generate responsive image srcset
export const generateResponsiveSrcset = (
  baseUrl: string,
  widths: number[],
  format: 'avif' | 'webp' | 'jpeg' = 'webp'
): string =>
  widths
    .map((width) => {
      const url = `${baseUrl}-${width}w.${format}`;
      return `${url} ${width}w`;
    })
    .join(', ');

// Generate optimized image URL
export const generateOptimizedImageUrl = (
  baseUrl: string,
  options: {
    width?: number;
    height?: number;
    quality?: number;
    format?: 'avif' | 'webp' | 'jpeg';
    blur?: boolean;
  } = {}
): string => {
  const {
    width,
    height,
    quality = 80,
    format = 'webp',
    blur = false,
  } = options;

  const params = new URLSearchParams();
  if (width) params.set('w', width.toString());
  if (height) params.set('h', height.toString());
  if (quality !== 80) params.set('q', quality.toString());
  if (blur) params.set('blur', '50');

  const formatParam = format === 'jpeg' ? 'jpg' : format;
  return `${baseUrl}.${formatParam}${params.toString() ? `?${params.toString()}` : ''}`;
};

// Image lazy loading with intersection observer
export class LazyImageLoader {
  private observer: IntersectionObserver;
  private config: IntersectionObserverInit;

  constructor(
    callback?: (entries: IntersectionObserverEntry[]) => void,
    config: IntersectionObserverInit = {}
  ) {
    this.config = {
      rootMargin: '50px',
      threshold: 0.01,
      ...config,
    };

    this.observer = new IntersectionObserver(
      callback || this.handleIntersection.bind(this),
      this.config
    );
  }

  observe(element: HTMLElement): void {
    this.observer.observe(element);
  }

  unobserve(element: HTMLElement): void {
    this.observer.unobserve(element);
  }

  disconnect(): void {
    this.observer.disconnect();
  }

  private handleIntersection(entries: IntersectionObserverEntry[]): void {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        const img = entry.target as HTMLImageElement;
        this.loadImage(img);
        this.unobserve(img);
      }
    });
  }

  private loadImage(img: HTMLImageElement): void {
    // eslint-disable-next-line dot-notation
    const src = img.dataset['src'];
    // eslint-disable-next-line dot-notation
    const srcset = img.dataset['srcset'];

    if (src) {
      img.src = src;
    }
    if (srcset) {
      img.srcset = srcset;
    }

    img.onload = () => {
      img.classList.add('loaded');
    };

    img.onerror = () => {
      img.classList.add('error');
    };
  }
}

// Image optimization configuration
export const imageOptimizationConfig: OptimizedImageConfig = {
  quality: 80,
  progressive: true,
  lossy: true,
  effort: 4,
};

// Responsive image configuration
export const responsiveImageConfig: ResponsiveImageConfig = {
  breakpoints: [320, 640, 768, 1024, 1280, 1536, 1920],
  formats: ['avif', 'webp', 'jpeg'],
  quality: 80,
  sizes: [
    '(max-width: 640px) 100vw',
    '(max-width: 768px) 100vw',
    '(max-width: 1024px) 100vw',
    '(max-width: 1280px) 100vw',
    '100vw',
  ],
};

// Preload critical images
export const preloadCriticalImages = (imageUrls: string[]): void => {
  imageUrls.forEach((url) => {
    const link = document.createElement('link');
    link.rel = 'preload';
    link.as = 'image';
    link.href = url;
    link.type = `image/${url.split('.').pop()}`;
    document.head.appendChild(link);
  });
};

// Generate blur placeholder for lazy loading
export const generateBlurPlaceholder = (): string =>
  // This would typically be handled by a build-time process
  // For now, return a simple data URL
  `data:image/svg+xml;base64,${btoa(`
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
      <defs>
        <filter id="blur">
          <feGaussianBlur stdDeviation="20" />
        </filter>
      </defs>
      <rect width="400" height="300" fill="#f0f0f0" filter="url(#blur)" />
    </svg>
  `)}`;


[FILE_END: utils\imageOptimization.ts]
################################################################################

================================================================================
FILE_BEGIN: vite.config.ts
TYPE: TS
SIZE: 7386 bytes
================================================================================
import path from 'path';
import { defineConfig, loadEnv } from 'vite';
import react from '@vitejs/plugin-react';
import { VitePWA } from 'vite-plugin-pwa';

interface EnvVariables {
  [key: string]: string;
  VITE_REPOSITORY_NAME?: string;
  VITE_USE_CUSTOM_DOMAIN?: string;
}

export default defineConfig(({ mode }) => {
  const env = loadEnv(mode, '.', '') as EnvVariables;

  // GitHub Pages configuration
  const isProduction = mode === 'production';
  // eslint-disable-next-line dot-notation
  const repositoryName = env['VITE_REPOSITORY_NAME'] || '';
  const useCustomDomain = env.VITE_USE_CUSTOM_DOMAIN === 'true';
  // For custom domain (CNAME), use root path '/'; for github.io pages, use repository path
  const base = isProduction
    ? useCustomDomain || !repositoryName
      ? '/'
      : `/${repositoryName}/`
    : '/';

  return {
    base,
    server: {
      port: 3000,
      host: '0.0.0.0',
      allowedHosts: ['p4c-web.onrender.com', 'p4c-web', '.onrender.com'],
      headers: {
        // Security Headers - CRITICAL for XSS Protection
        'X-Frame-Options': 'DENY',
        'X-Content-Type-Options': 'nosniff',
        'Referrer-Policy': 'strict-origin-when-cross-origin',
        'Permissions-Policy': 'camera=(), microphone=(), geolocation=()',
        'Strict-Transport-Security':
          'max-age=31536000; includeSubDomains; preload',
        // Content Security Policy - XSS Prevention
        'Content-Security-Policy':
          "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; img-src 'self' data: https:; font-src 'self' https://fonts.gstatic.com; connect-src 'self' https://p4c-web.onrender.com https://generativelanguage.googleapis.com; frame-src 'none'; object-src 'none'; base-uri 'self'; form-action 'self'; upgrade-insecure-requests;",
      },
      proxy: {
        // Proxy API calls to secure server
        '/api': {
          target: 'http://localhost:3001',
          changeOrigin: true,
          secure: false,
          rewrite: (path) => path,
        },
      },
    },
    plugins: [
      react(),
      // PWA configuration for installability and service worker
      VitePWA({
        registerType: 'autoUpdate',
        includeAssets: [
          'favicon.ico',
          'apple-touch-icon.png',
          'masked-icon.svg',
        ],
        manifest: {
          name: 'Properties 4 Creation',
          short_name: 'P4C',
          description:
            'Housing solutions for veterans and families in East Texas',
          theme_color: '#0B1120',
          background_color: '#0B1120',
          display: 'standalone',
          orientation: 'portrait',
          scope: '/',
          start_url: '/',
          icons: [
            {
              src: '/pwa-192x192.png',
              sizes: '192x192',
              type: 'image/png',
            },
            {
              src: '/pwa-512x512.png',
              sizes: '512x512',
              type: 'image/png',
            },
            {
              src: '/pwa-512x512.png',
              sizes: '512x512',
              type: 'image/png',
              purpose: 'any maskable',
            },
          ],
        },
        workbox: {
          maximumFileSizeToCacheInBytes: 10485760, // 10 MB to accommodate large banner images
          globPatterns: ['**/*.{js,css,html,ico,png,svg,webp,woff2}'],
          runtimeCaching: [
            {
              urlPattern: /^https:\/\/api\..*/i,
              handler: 'NetworkFirst',
              options: {
                cacheName: 'api-cache',
                expiration: {
                  maxEntries: 50,
                  maxAgeSeconds: 86400, // 24 hours in seconds
                },
              },
            },
            {
              urlPattern: /^https:\/fonts\.googleapis\.com\/.*/i,
              handler: 'CacheFirst',
              options: {
                cacheName: 'google-fonts-cache',
                expiration: {
                  maxEntries: 10,
                  maxAgeSeconds: 31536000, // 1 year in seconds
                },
              },
            },
            {
              urlPattern: /^https:\/fonts\.gstatic\.com\/.*/i,
              handler: 'CacheFirst',
              options: {
                cacheName: 'gstatic-fonts-cache',
                expiration: {
                  maxEntries: 10,
                  maxAgeSeconds: 31536000, // 1 year in seconds
                },
              },
            },
          ],
        },
      }),
    ],
    assetsInclude: ['**/*.bin', '**/*.json'], // Helps loading local TFJS models if needed
    define: {
      // REMOVED: API key exposure vulnerability (CRITICAL FIX)
      // API keys are now handled server-side only via proxy
      'process.env.NODE_ENV': JSON.stringify(mode),
      'process.env.VITE_API_BASE_URL': JSON.stringify('/api'),
    },
    resolve: {
      alias: {
        '@': path.resolve(__dirname, '.'),
      },
    },
    build: {
      target: 'es2020',
      sourcemap: mode !== 'production',
      minify: 'terser',
      cssMinify: true,
      // Performance optimizations
      rollupOptions: {
        output: {
          // Manual chunks for better caching
          manualChunks: {
            // React and React DOM together
            react: ['react', 'react-dom'],
            // Router
            router: ['react-router-dom'],
            // UI library
            ui: ['lucide-react'],
            // AI service
            ai: ['@google/generative-ai'],
            // Utils
            utils: ['react-helmet-async'],
          },
          // Optimize chunk file names
          chunkFileNames: 'js/[name]-[hash].js',
          assetFileNames: (assetInfo) => {
            if (/\.(png|jpe?g|gif|svg|webp)$/i.test(assetInfo.name || '')) {
              return 'images/[name]-[hash][extname]';
            }
            if (/\.(woff2?|eot|ttf|otf)$/i.test(assetInfo.name || '')) {
              return 'fonts/[name]-[hash][extname]';
            }
            return 'assets/[name]-[hash][extname]';
          },
        },
      },
      // Optimize terser options
      terserOptions: {
        compress: {
          drop_console: mode === 'production',
          pure_funcs:
            mode === 'production'
              ? ['console.log', 'console.info', 'console.debug']
              : [],
        },
      },
      // Chunk size warnings
      chunkSizeWarningLimit: 1000,
    },
    // Performance optimizations
    optimizeDeps: {
      include: [
        'react',
        'react-dom',
        'react-router-dom',
        'lucide-react',
        '@google/generative-ai',
      ],
    },
    // CSS optimizations
    css: {
      devSourcemap: mode !== 'production',
    },
    // Test configuration (Vitest)
    test: {
      environment: 'jsdom',
      globals: true,
      setupFiles: ['./src/test/setup.ts'],
      include: [
        'src/**/*.{test,spec}.{ts,tsx}',
        'services/**/*.{test,spec}.{ts,tsx}',
      ],
      coverage: {
        provider: 'v8',
        reporter: ['text', 'json', 'html'],
        include: ['src/**/*.ts', 'src/**/*.tsx'],
        exclude: [
          'src/**/*.test.ts',
          'src/types.ts',
          'node_modules/',
          'src/test/',
          '**/*.d.ts',
          '**/*.config.*',
        ],
      },
    },
  };
});


[FILE_END: vite.config.ts]
################################################################################
